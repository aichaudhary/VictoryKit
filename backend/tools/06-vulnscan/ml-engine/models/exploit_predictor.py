"""
VulnScan ML Engine - Exploit Predictor Model
Predict exploitation likelihood and attack vectors
"""

import numpy as np
import logging
from typing import Dict, Any, List
import re

logger = logging.getLogger(__name__)


class ExploitPredictor:
    """
    Predict vulnerability exploitability and attack characteristics.
    """
    
    def __init__(self):
        self.version = "1.0.0"
        self.is_loaded = True
        
        # Known exploited CVEs
        self.known_exploited = {
            "CVE-2021-44228",  # Log4j
            "CVE-2021-45046",  # Log4j
            "CVE-2022-22965",  # Spring4Shell
            "CVE-2023-44487",  # HTTP/2 Rapid Reset
            "CVE-2023-4863",   # WebP
            "CVE-2024-0001",   # Example
        }
        
        # Exploit maturity levels
        self.maturity_levels = {
            "NOT_DEFINED": 0,
            "UNPROVEN": 1,
            "POC": 2,
            "FUNCTIONAL": 3,
            "HIGH": 4
        }
        
        logger.info(f"Exploit Predictor v{self.version} loaded")
    
    def predict(self, vuln_data: Dict[str, Any]) -> Dict[str, Any]:
        """Predict exploitability"""
        
        cve_id = vuln_data.get("cve_id")
        title = vuln_data.get("title", "").lower()
        description = vuln_data.get("description", "").lower()
        
        # Check if known exploited
        known_exploits = cve_id in self.known_exploited if cve_id else False
        
        # Calculate exploitability score
        exploitability = self._calculate_exploitability(title, description, known_exploits)
        
        # Determine exploit maturity
        maturity = self._determine_maturity(known_exploits, description)
        
        # Identify attack vectors
        attack_vectors = self._identify_attack_vectors(title, description)
        
        # Estimate time to exploit
        time_to_exploit = self._estimate_time_to_exploit(exploitability, known_exploits)
        
        return {
            "exploitability_score": round(exploitability, 1),
            "known_exploits": known_exploits,
            "exploit_maturity": maturity,
            "time_to_exploit": time_to_exploit,
            "attack_vectors": attack_vectors
        }
    
    def predict_probability(self, vuln_data: Dict[str, Any]) -> float:
        """Predict exploitation probability"""
        
        result = self.predict(vuln_data)
        
        # Convert exploitability to probability
        probability = min(result["exploitability_score"] / 10 * 100, 100)
        
        if result["known_exploits"]:
            probability = min(probability + 20, 100)
        
        return round(probability, 1)
    
    def _calculate_exploitability(self, title: str, description: str, known_exploits: bool) -> float:
        """Calculate exploitability score (0-10)"""
        
        score = 5.0  # Base score
        text = f"{title} {description}"
        
        # Increase for high-risk indicators
        high_risk = [
            ("unauthenticated", 2.0),
            ("remote", 1.5),
            ("no user interaction", 1.5),
            ("public exploit", 2.0),
            ("actively exploited", 2.5),
            ("proof of concept", 1.0),
            ("metasploit", 1.5),
        ]
        
        for keyword, boost in high_risk:
            if keyword in text:
                score += boost
        
        # Decrease for mitigating factors
        low_risk = [
            ("requires authentication", -1.5),
            ("requires user interaction", -1.0),
            ("local only", -2.0),
            ("complex attack", -1.0),
            ("specific conditions", -0.5),
        ]
        
        for keyword, reduction in low_risk:
            if keyword in text:
                score += reduction
        
        # Known exploits boost
        if known_exploits:
            score = min(score + 2.0, 10.0)
        
        return max(min(score, 10.0), 0.0)
    
    def _determine_maturity(self, known_exploits: bool, description: str) -> str:
        """Determine exploit maturity level"""
        
        if known_exploits:
            return "HIGH"
        
        if "metasploit" in description or "exploit-db" in description:
            return "FUNCTIONAL"
        
        if "proof of concept" in description or "poc" in description:
            return "POC"
        
        if "theoretical" in description:
            return "UNPROVEN"
        
        return "NOT_DEFINED"
    
    def _identify_attack_vectors(self, title: str, description: str) -> List[str]:
        """Identify attack vectors"""
        
        vectors = []
        text = f"{title} {description}"
        
        vector_keywords = {
            "NETWORK": ["remote", "network", "internet", "web"],
            "LOCAL": ["local", "physical access"],
            "ADJACENT": ["adjacent network", "lan", "same network"],
            "PHISHING": ["email", "phishing", "social engineering"],
            "MALICIOUS_FILE": ["malicious file", "crafted file", "attachment"],
            "WEB_ATTACK": ["web request", "http", "url", "injection"],
            "API": ["api", "rest", "graphql"],
        }
        
        for vector, keywords in vector_keywords.items():
            if any(kw in text for kw in keywords):
                vectors.append(vector)
        
        return vectors if vectors else ["UNKNOWN"]
    
    def _estimate_time_to_exploit(self, exploitability: float, known_exploits: bool) -> str:
        """Estimate time to exploitation"""
        
        if known_exploits or exploitability >= 9.0:
            return "IMMEDIATE"
        elif exploitability >= 7.0:
            return "DAYS"
        elif exploitability >= 5.0:
            return "WEEKS"
        elif exploitability >= 3.0:
            return "MONTHS"
        else:
            return "UNLIKELY"
