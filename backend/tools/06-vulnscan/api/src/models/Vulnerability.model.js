/**
 * VulnScan - Vulnerability Model
 * Enterprise-grade vulnerability tracking with CVSS, exploitability, and correlation
 */

const mongoose = require('mongoose');

// CVSS v3.1 Vector Sub-schema
const cvssVectorSchema = new mongoose.Schema({
  attackVector: {
    type: String,
    enum: ['NETWORK', 'ADJACENT', 'LOCAL', 'PHYSICAL'],
    description: 'Attack Vector (AV)'
  },
  attackComplexity: {
    type: String,
    enum: ['LOW', 'HIGH'],
    description: 'Attack Complexity (AC)'
  },
  privilegesRequired: {
    type: String,
    enum: ['NONE', 'LOW', 'HIGH'],
    description: 'Privileges Required (PR)'
  },
  userInteraction: {
    type: String,
    enum: ['NONE', 'REQUIRED'],
    description: 'User Interaction (UI)'
  },
  scope: {
    type: String,
    enum: ['UNCHANGED', 'CHANGED'],
    description: 'Scope (S)'
  },
  confidentialityImpact: {
    type: String,
    enum: ['NONE', 'LOW', 'HIGH'],
    description: 'Confidentiality Impact (C)'
  },
  integrityImpact: {
    type: String,
    enum: ['NONE', 'LOW', 'HIGH'],
    description: 'Integrity Impact (I)'
  },
  availabilityImpact: {
    type: String,
    enum: ['NONE', 'LOW', 'HIGH'],
    description: 'Availability Impact (A)'
  }
}, { _id: false });

// Exploit Information Sub-schema
const exploitInfoSchema = new mongoose.Schema({
  available: {
    type: Boolean,
    default: false,
    description: 'Whether exploit is available'
  },
  publicExploit: {
    type: Boolean,
    default: false,
    description: 'Whether exploit is publicly available'
  },
  exploitMaturity: {
    type: String,
    enum: ['NOT_DEFINED', 'UNPROVEN', 'PROOF_OF_CONCEPT', 'FUNCTIONAL', 'HIGH'],
    default: 'NOT_DEFINED'
  },
  exploitSources: [{
    source: {
      type: String,
      enum: ['EXPLOIT_DB', 'METASPLOIT', 'GITHUB', 'PACKETSTORM', 'CUSTOM', 'VENDOR', 'OTHER']
    },
    id: String,
    url: String,
    title: String,
    datePublished: Date,
    reliability: {
      type: String,
      enum: ['UNTESTED', 'UNRELIABLE', 'RELIABLE', 'EXCELLENT']
    }
  }],
  metasploitModule: {
    name: String,
    path: String,
    rank: {
      type: String,
      enum: ['EXCELLENT', 'GREAT', 'GOOD', 'NORMAL', 'AVERAGE', 'LOW', 'MANUAL']
    }
  },
  proofOfConcepts: [{
    title: String,
    url: String,
    language: String,
    tested: Boolean,
    effectiveness: Number
  }],
  inTheWild: {
    type: Boolean,
    default: false,
    description: 'Whether exploit is being actively used in attacks'
  },
  cisaKev: {
    inCatalog: { type: Boolean, default: false },
    dateAdded: Date,
    dueDate: Date,
    notes: String
  }
}, { _id: false });

// Affected Product Sub-schema
const affectedProductSchema = new mongoose.Schema({
  vendor: {
    type: String,
    required: true
  },
  product: {
    type: String,
    required: true
  },
  version: {
    type: String
  },
  versionStartIncluding: String,
  versionStartExcluding: String,
  versionEndIncluding: String,
  versionEndExcluding: String,
  cpe: {
    type: String,
    description: 'Common Platform Enumeration identifier'
  },
  platform: String,
  update: String,
  edition: String
}, { _id: false });

// Remediation Information Sub-schema
const remediationInfoSchema = new mongoose.Schema({
  solution: {
    type: String,
    description: 'Recommended solution'
  },
  workaround: {
    type: String,
    description: 'Temporary workaround if patch not available'
  },
  mitigations: [{
    description: String,
    effectiveness: {
      type: String,
      enum: ['HIGH', 'MEDIUM', 'LOW', 'UNKNOWN']
    },
    effort: {
      type: String,
      enum: ['MINIMAL', 'LOW', 'MEDIUM', 'HIGH', 'VERY_HIGH']
    }
  }],
  patches: [{
    vendor: String,
    name: String,
    url: String,
    releaseDate: Date,
    version: String,
    kbArticle: String,
    supersededBy: String
  }],
  upgradeRequired: {
    type: Boolean,
    default: false
  },
  targetVersion: String,
  estimatedEffort: {
    type: String,
    enum: ['TRIVIAL', 'LOW', 'MEDIUM', 'HIGH', 'MAJOR_EFFORT']
  },
  estimatedDowntime: String,
  requiresRestart: Boolean,
  testingRequired: Boolean
}, { _id: false });

// Vulnerability Instance (per-asset finding)
const vulnerabilityInstanceSchema = new mongoose.Schema({
  assetId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'VulnScanAsset',
    required: true
  },
  scanId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'VulnScan'
  },
  affectedComponent: {
    name: String,
    version: String,
    path: String,
    port: Number,
    protocol: String,
    service: String
  },
  evidence: {
    type: {
      type: String,
      enum: ['BANNER', 'VERSION', 'RESPONSE', 'EXPLOIT_OUTPUT', 'CONFIGURATION', 'OTHER']
    },
    data: String,
    screenshot: String,
    requestResponse: {
      request: String,
      response: String
    }
  },
  parameters: mongoose.Schema.Types.Mixed,
  firstDetected: {
    type: Date,
    default: Date.now
  },
  lastSeen: {
    type: Date,
    default: Date.now
  },
  status: {
    type: String,
    enum: ['OPEN', 'ACKNOWLEDGED', 'IN_PROGRESS', 'PENDING_VERIFICATION', 'RESOLVED', 'RISK_ACCEPTED', 'FALSE_POSITIVE'],
    default: 'OPEN'
  },
  assignee: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  verificationResult: {
    verified: Boolean,
    verifiedAt: Date,
    verifiedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    method: String,
    notes: String
  }
}, { _id: true });

// Main Vulnerability Schema
const vulnerabilitySchema = new mongoose.Schema({
  // Identifiers
  vulnId: {
    type: String,
    required: true,
    unique: true,
    index: true,
    description: 'Internal vulnerability identifier'
  },
  cveId: {
    type: String,
    sparse: true,
    index: true,
    match: /^CVE-\d{4}-\d{4,}$/,
    description: 'CVE identifier'
  },
  cweIds: [{
    type: String,
    match: /^CWE-\d+$/,
    description: 'CWE identifiers'
  }],
  aliases: [{
    type: { type: String, enum: ['GHSA', 'OSV', 'SNYK', 'VENDOR', 'OTHER'] },
    id: String
  }],

  // Organization Context
  organizationId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Organization',
    required: true,
    index: true
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },

  // Basic Information
  title: {
    type: String,
    required: true,
    maxlength: 500
  },
  description: {
    type: String,
    required: true
  },
  technicalDescription: String,
  category: {
    type: String,
    enum: [
      'INJECTION', 'BROKEN_AUTH', 'SENSITIVE_DATA_EXPOSURE', 'XXE',
      'BROKEN_ACCESS_CONTROL', 'SECURITY_MISCONFIGURATION', 'XSS',
      'INSECURE_DESERIALIZATION', 'VULNERABLE_COMPONENTS', 'INSUFFICIENT_LOGGING',
      'SSRF', 'CRYPTOGRAPHIC_FAILURE', 'IDENTIFICATION_FAILURE',
      'SOFTWARE_DATA_INTEGRITY', 'SECURITY_LOGGING_FAILURE', 'OTHER'
    ],
    index: true
  },
  owaspCategory: {
    type: String,
    description: 'OWASP Top 10 category (e.g., A01:2021)'
  },

  // Severity and Scoring
  severity: {
    type: String,
    enum: ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFORMATIONAL'],
    required: true,
    index: true
  },
  cvssV3: {
    baseScore: {
      type: Number,
      min: 0,
      max: 10
    },
    temporalScore: {
      type: Number,
      min: 0,
      max: 10
    },
    environmentalScore: {
      type: Number,
      min: 0,
      max: 10
    },
    vectorString: String,
    vector: cvssVectorSchema
  },
  cvssV2: {
    score: Number,
    vectorString: String
  },
  epss: {
    score: {
      type: Number,
      min: 0,
      max: 1,
      description: 'Exploit Prediction Scoring System probability'
    },
    percentile: Number,
    date: Date
  },
  riskScore: {
    type: Number,
    min: 0,
    max: 100,
    description: 'Calculated risk score based on multiple factors'
  },

  // Affected Products
  affectedProducts: [affectedProductSchema],

  // Exploit Information
  exploit: exploitInfoSchema,

  // Remediation
  remediation: remediationInfoSchema,

  // Vulnerability Instances (affected assets)
  instances: [vulnerabilityInstanceSchema],
  instanceCount: {
    type: Number,
    default: 0
  },
  affectedAssetCount: {
    type: Number,
    default: 0
  },

  // References
  references: [{
    type: {
      type: String,
      enum: ['ADVISORY', 'ARTICLE', 'REPORT', 'PATCH', 'EXPLOIT', 'TOOL', 'MITIGATION', 'OTHER']
    },
    source: String,
    url: String,
    title: String
  }],

  // Dates
  publishedDate: {
    type: Date,
    description: 'When vulnerability was publicly disclosed'
  },
  lastModifiedDate: {
    type: Date,
    description: 'When vulnerability information was last updated'
  },
  firstDetected: {
    type: Date,
    default: Date.now,
    description: 'When first detected in environment'
  },
  lastSeen: {
    type: Date,
    default: Date.now
  },

  // Status Tracking
  status: {
    type: String,
    enum: ['OPEN', 'IN_PROGRESS', 'RESOLVED', 'RISK_ACCEPTED', 'FALSE_POSITIVE'],
    default: 'OPEN',
    index: true
  },
  statusHistory: [{
    status: String,
    changedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    changedAt: { type: Date, default: Date.now },
    reason: String
  }],
  resolvedAt: Date,
  resolvedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },

  // SLA Tracking
  sla: {
    dueDate: Date,
    breached: { type: Boolean, default: false },
    breachedAt: Date,
    extensionRequested: Boolean,
    extensionApproved: Boolean,
    newDueDate: Date
  },

  // Assignment
  assignedTo: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  assignedTeam: String,

  // ML/AI Analysis
  mlAnalysis: {
    predictedRisk: {
      type: String,
      enum: ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']
    },
    riskConfidence: Number,
    exploitProbability: Number,
    falsePositiveProbability: Number,
    priorityScore: Number,
    factors: [{
      name: String,
      impact: Number,
      description: String
    }],
    recommendations: [String],
    analyzedAt: Date
  },

  // Tags and Labels
  tags: [String],
  labels: [{
    key: String,
    value: String,
    color: String
  }],

  // Comments and Notes
  comments: [{
    userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    text: String,
    type: { type: String, enum: ['NOTE', 'UPDATE', 'QUESTION', 'RESOLUTION'] },
    createdAt: { type: Date, default: Date.now },
    attachments: [{
      filename: String,
      url: String,
      mimeType: String
    }]
  }],

  // Integration References
  integrationRefs: {
    jiraTicket: String,
    serviceNowIncident: String,
    githubIssue: String,
    gitlabIssue: String,
    customTicket: String
  },

  // Data Source
  source: {
    type: { type: String, enum: ['SCAN', 'IMPORT', 'MANUAL', 'THREAT_INTEL', 'VENDOR', 'CORRELATION'] },
    scanId: { type: mongoose.Schema.Types.ObjectId, ref: 'VulnScan' },
    scanner: String,
    importId: String,
    feedId: String
  },

  // Metadata
  metadata: mongoose.Schema.Types.Mixed,
  isActive: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true,
  collection: 'vulnscan_vulnerabilities'
});

// Indexes for optimized queries
vulnerabilitySchema.index({ organizationId: 1, severity: -1, status: 1 });
vulnerabilitySchema.index({ organizationId: 1, category: 1 });
vulnerabilitySchema.index({ cveId: 1 });
vulnerabilitySchema.index({ 'instances.assetId': 1 });
vulnerabilitySchema.index({ 'exploit.available': 1, severity: -1 });
vulnerabilitySchema.index({ 'sla.dueDate': 1, 'sla.breached': 1 });
vulnerabilitySchema.index({ assignedTo: 1, status: 1 });
vulnerabilitySchema.index({ publishedDate: -1 });
vulnerabilitySchema.index({ riskScore: -1 });
vulnerabilitySchema.index({ tags: 1 });
vulnerabilitySchema.index({ 'mlAnalysis.priorityScore': -1 });
vulnerabilitySchema.index({ 'affectedProducts.vendor': 1, 'affectedProducts.product': 1 });

// Text search index
vulnerabilitySchema.index({
  title: 'text',
  description: 'text',
  'remediation.solution': 'text'
});

// Virtual for severity as number
vulnerabilitySchema.virtual('severityLevel').get(function() {
  const levels = { CRITICAL: 5, HIGH: 4, MEDIUM: 3, LOW: 2, INFORMATIONAL: 1 };
  return levels[this.severity] || 0;
});

// Virtual for age in days
vulnerabilitySchema.virtual('ageInDays').get(function() {
  return Math.floor((Date.now() - this.firstDetected) / (1000 * 60 * 60 * 24));
});

// Virtual for SLA status
vulnerabilitySchema.virtual('slaStatus').get(function() {
  if (!this.sla?.dueDate) return 'NOT_SET';
  if (this.status === 'RESOLVED' || this.status === 'FALSE_POSITIVE') return 'RESOLVED';
  if (this.sla.breached) return 'BREACHED';
  
  const now = new Date();
  const dueDate = new Date(this.sla.dueDate);
  const hoursRemaining = (dueDate - now) / (1000 * 60 * 60);
  
  if (hoursRemaining <= 0) return 'OVERDUE';
  if (hoursRemaining <= 24) return 'DUE_SOON';
  return 'ON_TRACK';
});

// Method to calculate risk score
vulnerabilitySchema.methods.calculateRiskScore = function() {
  let score = 0;
  
  // Base CVSS score (40% weight)
  const cvssScore = this.cvssV3?.baseScore || 0;
  score += (cvssScore / 10) * 40;
  
  // Exploitability (25% weight)
  if (this.exploit?.inTheWild) score += 25;
  else if (this.exploit?.publicExploit) score += 20;
  else if (this.exploit?.available) score += 15;
  
  // EPSS score (15% weight)
  if (this.epss?.score) {
    score += this.epss.score * 15;
  }
  
  // Asset count impact (10% weight)
  const assetMultiplier = Math.min(this.affectedAssetCount / 10, 1);
  score += assetMultiplier * 10;
  
  // Age factor (10% weight) - older unresolved = higher risk
  const ageDays = this.ageInDays || 0;
  const ageFactor = Math.min(ageDays / 90, 1);
  score += ageFactor * 10;
  
  this.riskScore = Math.round(score);
  return this.riskScore;
};

// Method to add vulnerability instance
vulnerabilitySchema.methods.addInstance = function(instanceData) {
  const existingIndex = this.instances.findIndex(
    i => i.assetId.toString() === instanceData.assetId.toString()
  );
  
  if (existingIndex >= 0) {
    // Update existing instance
    this.instances[existingIndex].lastSeen = new Date();
    if (instanceData.evidence) {
      this.instances[existingIndex].evidence = instanceData.evidence;
    }
  } else {
    // Add new instance
    this.instances.push(instanceData);
  }
  
  // Update counts
  this.instanceCount = this.instances.length;
  this.affectedAssetCount = new Set(this.instances.map(i => i.assetId.toString())).size;
  this.lastSeen = new Date();
  
  return this.save();
};

// Method to update status
vulnerabilitySchema.methods.updateStatus = function(newStatus, userId, reason) {
  this.statusHistory.push({
    status: newStatus,
    changedBy: userId,
    changedAt: new Date(),
    reason: reason
  });
  
  this.status = newStatus;
  
  if (newStatus === 'RESOLVED' || newStatus === 'FALSE_POSITIVE') {
    this.resolvedAt = new Date();
    this.resolvedBy = userId;
  }
  
  return this.save();
};

// Pre-save hook for risk calculation
vulnerabilitySchema.pre('save', function(next) {
  if (this.isModified('cvssV3') || this.isModified('exploit') || this.isModified('instances')) {
    this.calculateRiskScore();
  }
  next();
});

// Static method for severity statistics
vulnerabilitySchema.statics.getSeverityStats = async function(organizationId, filters = {}) {
  const match = { organizationId, isActive: true, ...filters };
  
  return this.aggregate([
    { $match: match },
    {
      $group: {
        _id: '$severity',
        count: { $sum: 1 },
        avgRiskScore: { $avg: '$riskScore' },
        withExploit: {
          $sum: { $cond: ['$exploit.available', 1, 0] }
        }
      }
    },
    { $sort: { _id: 1 } }
  ]);
};

// Static method for top vulnerabilities by risk
vulnerabilitySchema.statics.getTopByRisk = async function(organizationId, limit = 10) {
  return this.find({
    organizationId,
    isActive: true,
    status: { $in: ['OPEN', 'IN_PROGRESS'] }
  })
    .sort({ riskScore: -1, 'cvssV3.baseScore': -1 })
    .limit(limit)
    .populate('assignedTo', 'name email')
    .select('vulnId cveId title severity riskScore affectedAssetCount exploit.available sla');
};

module.exports = mongoose.model('VulnScanVulnerability', vulnerabilitySchema);
