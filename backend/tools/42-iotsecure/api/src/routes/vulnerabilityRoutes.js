/**
 * Vulnerability Routes - CVE and Vulnerability Management
 */

const express = require('express');
const router = express.Router();
const axios = require('axios');
const { Vulnerability, Device } = require('../models');

const NVD_API_URL = process.env.NVD_API_URL || 'https://services.nvd.nist.gov/rest/json/cves/2.0';
const NVD_API_KEY = process.env.NVD_API_KEY;

// GET /vulnerabilities - List all vulnerabilities
router.get('/', async (req, res) => {
  try {
    const { 
      severity, status, exploitable, source,
      page = 1, limit = 50, sort = '-cvssScore' 
    } = req.query;
    
    const query = {};
    if (severity) query.severity = severity;
    if (status) query.status = status;
    if (exploitable !== undefined) query.exploitable = exploitable === 'true';
    if (source) query.source = source;
    
    const [vulnerabilities, total] = await Promise.all([
      Vulnerability.find(query)
        .sort(sort)
        .skip((page - 1) * limit)
        .limit(parseInt(limit)),
      Vulnerability.countDocuments(query)
    ]);
    
    res.json({ 
      success: true, 
      data: vulnerabilities,
      pagination: { page: parseInt(page), limit: parseInt(limit), total, pages: Math.ceil(total / limit) }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /vulnerabilities/stats - Get vulnerability statistics
router.get('/stats', async (req, res) => {
  try {
    const stats = await Vulnerability.getStats();
    res.json({ success: true, data: stats });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /vulnerabilities/critical - Get critical vulnerabilities
router.get('/critical', async (req, res) => {
  try {
    const vulnerabilities = await Vulnerability.getCritical();
    res.json({ success: true, data: vulnerabilities });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /vulnerabilities/exploitable - Get exploitable vulnerabilities
router.get('/exploitable', async (req, res) => {
  try {
    const vulnerabilities = await Vulnerability.getExploitable();
    res.json({ success: true, data: vulnerabilities });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /vulnerabilities/search-nvd - Search NVD for CVEs
router.get('/search-nvd', async (req, res) => {
  try {
    const { keyword, cveId, vendor, product } = req.query;
    
    const params = {};
    if (keyword) params.keywordSearch = keyword;
    if (cveId) params.cveId = cveId;
    if (vendor) params.cpeName = `cpe:2.3:*:${vendor}:*`;
    if (product) params.cpeName = params.cpeName ? `${params.cpeName}:${product}` : `cpe:2.3:*:*:${product}`;
    
    const headers = {};
    if (NVD_API_KEY) headers['apiKey'] = NVD_API_KEY;
    
    const response = await axios.get(NVD_API_URL, { params, headers });
    
    const cves = response.data.vulnerabilities?.map(v => ({
      cveId: v.cve.id,
      description: v.cve.descriptions?.find(d => d.lang === 'en')?.value,
      publishedDate: v.cve.published,
      lastModifiedDate: v.cve.lastModified,
      cvssScore: v.cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore ||
                 v.cve.metrics?.cvssMetricV30?.[0]?.cvssData?.baseScore ||
                 v.cve.metrics?.cvssMetricV2?.[0]?.cvssData?.baseScore,
      cvssVector: v.cve.metrics?.cvssMetricV31?.[0]?.cvssData?.vectorString ||
                  v.cve.metrics?.cvssMetricV30?.[0]?.cvssData?.vectorString,
      severity: v.cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseSeverity?.toLowerCase() || 'medium',
      references: v.cve.references?.map(r => ({ url: r.url, source: r.source }))
    })) || [];
    
    res.json({ success: true, data: cves, total: response.data.totalResults });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /vulnerabilities/:id - Get vulnerability by ID
router.get('/:id', async (req, res) => {
  try {
    const vulnerability = await Vulnerability.findById(req.params.id)
      .populate('affectedDevices', 'name ipAddress type status');
    
    if (!vulnerability) {
      return res.status(404).json({ success: false, error: 'Vulnerability not found' });
    }
    
    res.json({ success: true, data: vulnerability });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// GET /vulnerabilities/cve/:cveId - Get by CVE ID
router.get('/cve/:cveId', async (req, res) => {
  try {
    const vulnerability = await Vulnerability.searchByCVE(req.params.cveId);
    
    if (!vulnerability) {
      return res.status(404).json({ success: false, error: 'CVE not found' });
    }
    
    res.json({ success: true, data: vulnerability });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /vulnerabilities - Create vulnerability record
router.post('/', async (req, res) => {
  try {
    const vulnerability = new Vulnerability({
      ...req.body,
      discoveredAt: new Date(),
      createdBy: req.body.userId || 'system'
    });
    
    await vulnerability.save();
    
    if (global.io) {
      global.io.to('vulnerabilities').emit('vulnerability-created', vulnerability);
    }
    
    res.status(201).json({ success: true, data: vulnerability });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
});

// PUT /vulnerabilities/:id - Update vulnerability
router.put('/:id', async (req, res) => {
  try {
    const vulnerability = await Vulnerability.findByIdAndUpdate(
      req.params.id,
      { ...req.body, updatedBy: req.body.userId || 'system' },
      { new: true, runValidators: true }
    );
    
    if (!vulnerability) {
      return res.status(404).json({ success: false, error: 'Vulnerability not found' });
    }
    
    res.json({ success: true, data: vulnerability });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
});

// PUT /vulnerabilities/:id/status - Update status
router.put('/:id/status', async (req, res) => {
  try {
    const { status, resolution } = req.body;
    const updateData = { status };
    
    if (status === 'resolved') {
      updateData.resolvedAt = new Date();
    } else if (status === 'mitigated') {
      updateData.mitigatedAt = new Date();
    }
    
    if (resolution) {
      updateData['remediation.description'] = resolution;
    }
    
    const vulnerability = await Vulnerability.findByIdAndUpdate(
      req.params.id,
      updateData,
      { new: true }
    );
    
    if (!vulnerability) {
      return res.status(404).json({ success: false, error: 'Vulnerability not found' });
    }
    
    res.json({ success: true, data: vulnerability });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
});

// DELETE /vulnerabilities/:id - Delete vulnerability
router.delete('/:id', async (req, res) => {
  try {
    const vulnerability = await Vulnerability.findByIdAndDelete(req.params.id);
    
    if (!vulnerability) {
      return res.status(404).json({ success: false, error: 'Vulnerability not found' });
    }
    
    res.json({ success: true, message: 'Vulnerability deleted' });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// POST /vulnerabilities/:id/link-devices - Link vulnerability to devices
router.post('/:id/link-devices', async (req, res) => {
  try {
    const { deviceIds } = req.body;
    
    const vulnerability = await Vulnerability.findByIdAndUpdate(
      req.params.id,
      { 
        $addToSet: { affectedDevices: { $each: deviceIds } },
        affectedCount: deviceIds.length
      },
      { new: true }
    );
    
    if (!vulnerability) {
      return res.status(404).json({ success: false, error: 'Vulnerability not found' });
    }
    
    // Update devices with vulnerability reference
    await Device.updateMany(
      { _id: { $in: deviceIds } },
      { 
        $addToSet: { vulnerabilities: vulnerability._id },
        $inc: { vulnerabilityCount: 1 }
      }
    );
    
    res.json({ success: true, data: vulnerability });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

module.exports = router;
