/**
 * Vulnerability Controller
 * Handles vulnerability management operations
 */

const { Vulnerability, Device } = require('../models');
const nvdService = require('../services/nvdService');

// Helper for pagination
const getPagination = (req) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 20;
  const skip = (page - 1) * limit;
  return { page, limit, skip };
};

/**
 * Get all vulnerabilities with filtering
 */
exports.getVulnerabilities = async (req, res) => {
  try {
    const { page, limit, skip } = getPagination(req);
    
    const filter = {};
    if (req.query.severity) filter.severity = req.query.severity;
    if (req.query.status) filter.status = req.query.status;
    if (req.query.exploitAvailable === 'true') filter.exploitAvailable = true;
    if (req.query.patchAvailable === 'true') filter.patchAvailable = true;
    
    const [vulnerabilities, total] = await Promise.all([
      Vulnerability.find(filter)
        .sort({ cvssV3Score: -1 })
        .skip(skip)
        .limit(limit)
        .populate('affectedDevices.deviceId', 'name ipAddress'),
      Vulnerability.countDocuments(filter)
    ]);
    
    res.json({
      success: true,
      data: vulnerabilities,
      pagination: { page, limit, total, pages: Math.ceil(total / limit) }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

/**
 * Get vulnerability statistics
 */
exports.getVulnerabilityStats = async (req, res) => {
  try {
    const stats = await Vulnerability.getStats();
    res.json({ success: true, data: stats });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

/**
 * Get critical open vulnerabilities
 */
exports.getCriticalVulnerabilities = async (req, res) => {
  try {
    const vulnerabilities = await Vulnerability.getCriticalOpen();
    res.json({ success: true, data: vulnerabilities, count: vulnerabilities.length });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

/**
 * Get exploitable vulnerabilities
 */
exports.getExploitableVulnerabilities = async (req, res) => {
  try {
    const vulnerabilities = await Vulnerability.getExploitable();
    res.json({ success: true, data: vulnerabilities, count: vulnerabilities.length });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

/**
 * Get vulnerabilities by severity
 */
exports.getBySeverity = async (req, res) => {
  try {
    const { severity } = req.params;
    const { page, limit, skip } = getPagination(req);
    
    const [vulnerabilities, total] = await Promise.all([
      Vulnerability.find({ severity }).skip(skip).limit(limit),
      Vulnerability.countDocuments({ severity })
    ]);
    
    res.json({
      success: true,
      data: vulnerabilities,
      pagination: { page, limit, total, pages: Math.ceil(total / limit) }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

/**
 * Get vulnerabilities by device
 */
exports.getByDevice = async (req, res) => {
  try {
    const { deviceId } = req.params;
    const vulnerabilities = await Vulnerability.find({
      'affectedDevices.deviceId': deviceId
    }).sort({ cvssV3Score: -1 });
    
    res.json({ success: true, data: vulnerabilities, count: vulnerabilities.length });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

/**
 * Search vulnerabilities
 */
exports.searchVulnerabilities = async (req, res) => {
  try {
    const { q } = req.query;
    if (!q) {
      return res.status(400).json({ success: false, error: 'Search query required' });
    }
    
    const searchRegex = new RegExp(q, 'i');
    const vulnerabilities = await Vulnerability.find({
      $or: [
        { cveId: searchRegex },
        { title: searchRegex },
        { description: searchRegex },
        { 'affectedProducts.product': searchRegex }
      ]
    }).limit(50);
    
    res.json({ success: true, data: vulnerabilities, count: vulnerabilities.length });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

/**
 * CVE lookup from NVD
 */
exports.lookupCVE = async (req, res) => {
  try {
    const { cveId } = req.params;
    
    // First check local database
    let vulnerability = await Vulnerability.findOne({ cveId });
    
    // If not found locally, fetch from NVD
    if (!vulnerability && process.env.NVD_API_KEY) {
      const nvdData = await nvdService.getCVE(cveId);
      if (nvdData) {
        vulnerability = await Vulnerability.create(nvdService.mapToSchema(nvdData));
      }
    }
    
    if (!vulnerability) {
      return res.status(404).json({ success: false, error: 'CVE not found' });
    }
    
    res.json({ success: true, data: vulnerability });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

/**
 * Sync with NVD
 */
exports.syncWithNVD = async (req, res) => {
  try {
    const { keywords, startDate, endDate } = req.body;
    
    if (!process.env.NVD_API_KEY) {
      return res.status(400).json({ 
        success: false, 
        error: 'NVD API key not configured' 
      });
    }
    
    // Fetch CVEs from NVD
    const cves = await nvdService.searchCVEs({
      keywordSearch: keywords,
      pubStartDate: startDate,
      pubEndDate: endDate
    });
    
    // Upsert into database
    let created = 0;
    let updated = 0;
    
    for (const cve of cves) {
      const mapped = nvdService.mapToSchema(cve);
      const result = await Vulnerability.updateOne(
        { cveId: mapped.cveId },
        { $set: mapped },
        { upsert: true }
      );
      if (result.upsertedCount) created++;
      else if (result.modifiedCount) updated++;
    }
    
    res.json({ 
      success: true, 
      message: 'NVD sync completed',
      stats: { fetched: cves.length, created, updated }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

/**
 * Get single vulnerability
 */
exports.getVulnerabilityById = async (req, res) => {
  try {
    const vulnerability = await Vulnerability.findById(req.params.id)
      .populate('affectedDevices.deviceId', 'name ipAddress type');
    
    if (!vulnerability) {
      return res.status(404).json({ success: false, error: 'Vulnerability not found' });
    }
    
    res.json({ success: true, data: vulnerability });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

/**
 * Create vulnerability
 */
exports.createVulnerability = async (req, res) => {
  try {
    const vulnerability = await Vulnerability.create(req.body);
    res.status(201).json({ success: true, data: vulnerability });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

/**
 * Update vulnerability
 */
exports.updateVulnerability = async (req, res) => {
  try {
    const vulnerability = await Vulnerability.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true, runValidators: true }
    );
    
    if (!vulnerability) {
      return res.status(404).json({ success: false, error: 'Vulnerability not found' });
    }
    
    res.json({ success: true, data: vulnerability });
  } catch (error) {
    res.status(400).json({ success: false, error: error.message });
  }
};

/**
 * Delete vulnerability
 */
exports.deleteVulnerability = async (req, res) => {
  try {
    const vulnerability = await Vulnerability.findByIdAndDelete(req.params.id);
    
    if (!vulnerability) {
      return res.status(404).json({ success: false, error: 'Vulnerability not found' });
    }
    
    res.json({ success: true, message: 'Vulnerability deleted' });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

/**
 * Acknowledge vulnerability
 */
exports.acknowledgeVulnerability = async (req, res) => {
  try {
    const vulnerability = await Vulnerability.findById(req.params.id);
    
    if (!vulnerability) {
      return res.status(404).json({ success: false, error: 'Vulnerability not found' });
    }
    
    await vulnerability.acknowledge(req.body.userId, req.body.notes);
    res.json({ success: true, data: vulnerability });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

/**
 * Resolve vulnerability
 */
exports.resolveVulnerability = async (req, res) => {
  try {
    const vulnerability = await Vulnerability.findById(req.params.id);
    
    if (!vulnerability) {
      return res.status(404).json({ success: false, error: 'Vulnerability not found' });
    }
    
    await vulnerability.resolve(req.body.resolution);
    res.json({ success: true, data: vulnerability });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

/**
 * Assign vulnerability
 */
exports.assignVulnerability = async (req, res) => {
  try {
    const { userId, userName } = req.body;
    
    const vulnerability = await Vulnerability.findByIdAndUpdate(
      req.params.id,
      { 
        'assignment.userId': userId,
        'assignment.userName': userName,
        'assignment.assignedAt': new Date()
      },
      { new: true }
    );
    
    if (!vulnerability) {
      return res.status(404).json({ success: false, error: 'Vulnerability not found' });
    }
    
    res.json({ success: true, data: vulnerability });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

/**
 * Add note to vulnerability
 */
exports.addNote = async (req, res) => {
  try {
    const vulnerability = await Vulnerability.findById(req.params.id);
    
    if (!vulnerability) {
      return res.status(404).json({ success: false, error: 'Vulnerability not found' });
    }
    
    vulnerability.notes.push({
      userId: req.body.userId,
      userName: req.body.userName,
      content: req.body.content,
      timestamp: new Date()
    });
    
    await vulnerability.save();
    res.json({ success: true, data: vulnerability });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

/**
 * Bulk acknowledge
 */
exports.bulkAcknowledge = async (req, res) => {
  try {
    const { vulnerabilityIds, userId, notes } = req.body;
    
    const result = await Vulnerability.updateMany(
      { _id: { $in: vulnerabilityIds } },
      { 
        $set: { 
          status: 'in_progress',
          'timeline.acknowledged': new Date(),
          'assignment.userId': userId
        }
      }
    );
    
    res.json({ success: true, modified: result.modifiedCount });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

/**
 * Bulk resolve
 */
exports.bulkResolve = async (req, res) => {
  try {
    const { vulnerabilityIds, resolution } = req.body;
    
    const result = await Vulnerability.updateMany(
      { _id: { $in: vulnerabilityIds } },
      { 
        $set: { 
          status: 'resolved',
          'timeline.resolved': new Date(),
          resolution
        }
      }
    );
    
    res.json({ success: true, modified: result.modifiedCount });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

/**
 * Export to CSV
 */
exports.exportCSV = async (req, res) => {
  try {
    const vulnerabilities = await Vulnerability.find({}).lean();
    
    const headers = ['cveId', 'title', 'severity', 'cvssV3Score', 'status', 'exploitAvailable', 'patchAvailable'];
    const rows = vulnerabilities.map(v => 
      headers.map(h => v[h] || '').join(',')
    );
    
    const csv = [headers.join(','), ...rows].join('\n');
    
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', 'attachment; filename=vulnerabilities.csv');
    res.send(csv);
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};

/**
 * Export to JSON
 */
exports.exportJSON = async (req, res) => {
  try {
    const vulnerabilities = await Vulnerability.find({}).lean();
    
    res.setHeader('Content-Type', 'application/json');
    res.setHeader('Content-Disposition', 'attachment; filename=vulnerabilities.json');
    res.json(vulnerabilities);
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
};
