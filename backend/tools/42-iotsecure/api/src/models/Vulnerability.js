/**
 * Vulnerability Model - CVE/Security Vulnerability Tracking
 * Tracks vulnerabilities discovered in IoT devices
 */

const mongoose = require('mongoose');

const vulnerabilitySchema = new mongoose.Schema({
  cveId: {
    type: String,
    unique: true,
    sparse: true,
    index: true
  },
  title: {
    type: String,
    required: true
  },
  description: {
    type: String,
    required: true
  },
  
  // Severity
  severity: {
    type: String,
    enum: ['critical', 'high', 'medium', 'low', 'info'],
    required: true,
    index: true
  },
  cvssScore: {
    type: Number,
    min: 0,
    max: 10
  },
  cvssVector: String,
  
  // Status
  status: {
    type: String,
    enum: ['open', 'in_progress', 'mitigated', 'resolved', 'accepted', 'false_positive'],
    default: 'open',
    index: true
  },
  
  // Exploitability
  exploitable: { type: Boolean, default: false },
  exploitAvailable: { type: Boolean, default: false },
  exploitMaturity: {
    type: String,
    enum: ['proof_of_concept', 'functional', 'weaponized', 'unknown'],
    default: 'unknown'
  },
  
  // Affected Components
  affectedDevices: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Device' }],
  affectedFirmware: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Firmware' }],
  affectedCount: { type: Number, default: 0 },
  
  // Vendor Info
  vendor: String,
  product: String,
  affectedVersions: [String],
  
  // References
  references: [{
    url: String,
    source: String,
    type: { type: String, enum: ['advisory', 'patch', 'exploit', 'article'] }
  }],
  
  // Remediation
  remediation: {
    available: Boolean,
    description: String,
    patchUrl: String,
    workaround: String,
    estimatedEffort: { type: String, enum: ['low', 'medium', 'high'] }
  },
  
  // Discovery
  discoveredAt: { type: Date, default: Date.now },
  discoveredBy: String,
  source: {
    type: String,
    enum: ['nvd', 'shodan', 'censys', 'manual', 'scan', 'vendor', 'greynoise'],
    default: 'scan'
  },
  
  // Timeline
  publishedDate: Date,
  lastModifiedDate: Date,
  mitigatedAt: Date,
  resolvedAt: Date,
  
  // Risk Assessment
  businessImpact: {
    type: String,
    enum: ['critical', 'high', 'medium', 'low', 'none'],
    default: 'medium'
  },
  attackVector: {
    type: String,
    enum: ['network', 'adjacent', 'local', 'physical'],
    default: 'network'
  },
  
  // Tags
  tags: [String],
  notes: String,
  
  // Audit
  assignedTo: String,
  createdBy: String,
  updatedBy: String
}, { timestamps: true });

// Indexes
vulnerabilitySchema.index({ severity: 1, status: 1 });
vulnerabilitySchema.index({ exploitable: 1, status: 1 });
vulnerabilitySchema.index({ discoveredAt: -1 });

// Static methods
vulnerabilitySchema.statics.getStats = async function() {
  const [total, bySeverity, byStatus, exploitable] = await Promise.all([
    this.countDocuments(),
    this.aggregate([{ $group: { _id: '$severity', count: { $sum: 1 } } }]),
    this.aggregate([{ $group: { _id: '$status', count: { $sum: 1 } } }]),
    this.countDocuments({ exploitable: true, status: 'open' })
  ]);
  return { 
    total, 
    bySeverity: bySeverity.reduce((acc, s) => ({ ...acc, [s._id]: s.count }), {}),
    byStatus: byStatus.reduce((acc, s) => ({ ...acc, [s._id]: s.count }), {}),
    exploitable
  };
};

vulnerabilitySchema.statics.getOpen = function() {
  return this.find({ status: 'open' }).sort({ cvssScore: -1, discoveredAt: -1 });
};

vulnerabilitySchema.statics.getExploitable = function() {
  return this.find({ exploitable: true, status: 'open' }).sort({ cvssScore: -1 });
};

vulnerabilitySchema.statics.getCritical = function() {
  return this.find({ severity: 'critical', status: 'open' }).sort({ discoveredAt: -1 });
};

vulnerabilitySchema.statics.getByDevice = function(deviceId) {
  return this.find({ affectedDevices: deviceId }).sort({ cvssScore: -1 });
};

vulnerabilitySchema.statics.searchByCVE = function(cveId) {
  return this.findOne({ cveId: cveId.toUpperCase() });
};

module.exports = mongoose.model('Vulnerability', vulnerabilitySchema);
