const mongoose = require('mongoose');

const vulnerabilitySchema = new mongoose.Schema({
  // CVE Information
  cveId: {
    type: String,
    required: true,
    unique: true,
    index: true,
    match: /^CVE-\d{4}-\d+$/
  },
  
  // Device Reference
  deviceId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Device',
    index: true
  },
  deviceIds: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Device'
  }],
  
  // Severity
  severity: {
    type: String,
    enum: ['critical', 'high', 'medium', 'low', 'informational'],
    required: true,
    index: true
  },
  
  // CVSS Scores
  cvssV3: {
    score: { type: Number, min: 0, max: 10 },
    vector: String,
    attackVector: {
      type: String,
      enum: ['NETWORK', 'ADJACENT_NETWORK', 'LOCAL', 'PHYSICAL']
    },
    attackComplexity: {
      type: String,
      enum: ['LOW', 'HIGH']
    },
    privilegesRequired: {
      type: String,
      enum: ['NONE', 'LOW', 'HIGH']
    },
    userInteraction: {
      type: String,
      enum: ['NONE', 'REQUIRED']
    },
    scope: {
      type: String,
      enum: ['UNCHANGED', 'CHANGED']
    },
    confidentialityImpact: {
      type: String,
      enum: ['NONE', 'LOW', 'HIGH']
    },
    integrityImpact: {
      type: String,
      enum: ['NONE', 'LOW', 'HIGH']
    },
    availabilityImpact: {
      type: String,
      enum: ['NONE', 'LOW', 'HIGH']
    }
  },
  cvssV2: {
    score: { type: Number, min: 0, max: 10 },
    vector: String
  },
  
  // Description
  title: {
    type: String,
    required: true
  },
  description: {
    type: String,
    required: true
  },
  
  // Affected Components
  affectedComponent: String,
  affectedVersions: [String],
  fixedVersions: [String],
  
  // Categorization
  cweId: String,
  cweName: String,
  category: {
    type: String,
    enum: [
      'authentication_bypass', 'remote_code_execution', 'sql_injection',
      'xss', 'buffer_overflow', 'information_disclosure', 'dos',
      'privilege_escalation', 'default_credentials', 'hardcoded_credentials',
      'insecure_protocol', 'firmware_vulnerability', 'api_vulnerability',
      'cryptographic_issue', 'configuration_issue', 'other'
    ]
  },
  
  // Exploit Information
  exploitAvailable: {
    type: Boolean,
    default: false,
    index: true
  },
  exploitDetails: {
    publicExploit: Boolean,
    exploitedInWild: Boolean,
    exploitMaturity: {
      type: String,
      enum: ['unproven', 'proof_of_concept', 'functional', 'high']
    },
    exploitUrl: String,
    metasploitModule: String
  },
  
  // Remediation
  patchAvailable: {
    type: Boolean,
    default: false
  },
  remediation: {
    type: String
  },
  remediationSteps: [String],
  workaround: String,
  patchUrl: String,
  
  // Status Tracking
  status: {
    type: String,
    enum: ['open', 'in_progress', 'mitigated', 'accepted', 'resolved', 'false_positive'],
    default: 'open',
    index: true
  },
  
  // Timeline
  publishedAt: Date,
  modifiedAt: Date,
  discoveredAt: {
    type: Date,
    default: Date.now
  },
  acknowledgedAt: Date,
  resolvedAt: Date,
  dueDate: Date,
  
  // Assignment
  assignedTo: {
    name: String,
    email: String,
    userId: String
  },
  
  // Risk Context
  riskContext: {
    businessImpact: {
      type: String,
      enum: ['critical', 'high', 'medium', 'low']
    },
    exposureLevel: {
      type: String,
      enum: ['internet_facing', 'internal', 'isolated']
    },
    dataAtRisk: [String],
    complianceImpact: [String]
  },
  
  // References
  references: [{
    type: { type: String },
    url: String,
    name: String
  }],
  vendorAdvisory: String,
  
  // Detection
  detectionMethod: {
    type: String,
    enum: ['scan', 'manual', 'threat_intel', 'vendor_notification', 'penetration_test']
  },
  scanId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Scan'
  },
  
  // Notes
  notes: [{
    author: String,
    content: String,
    createdAt: { type: Date, default: Date.now }
  }],
  
  // Metadata
  metadata: {
    type: mongoose.Schema.Types.Mixed,
    default: {}
  },
  
  // Audit
  createdBy: String,
  updatedBy: String
}, {
  timestamps: true
});

// Indexes
vulnerabilitySchema.index({ severity: 1, status: 1 });
vulnerabilitySchema.index({ discoveredAt: -1 });
vulnerabilitySchema.index({ 'cvssV3.score': -1 });
vulnerabilitySchema.index({ exploitAvailable: 1, patchAvailable: 1 });

// Virtual for age in days
vulnerabilitySchema.virtual('ageInDays').get(function() {
  return Math.floor((Date.now() - this.discoveredAt) / (1000 * 60 * 60 * 24));
});

// Virtual for SLA status
vulnerabilitySchema.virtual('slaStatus').get(function() {
  if (this.status === 'resolved') return 'completed';
  if (!this.dueDate) return 'no_sla';
  
  const now = new Date();
  if (now > this.dueDate) return 'overdue';
  
  const daysRemaining = Math.ceil((this.dueDate - now) / (1000 * 60 * 60 * 24));
  if (daysRemaining <= 7) return 'at_risk';
  return 'on_track';
});

// Static method to get open critical/high vulnerabilities
vulnerabilitySchema.statics.getCriticalOpen = function() {
  return this.find({
    status: 'open',
    severity: { $in: ['critical', 'high'] }
  })
  .sort({ 'cvssV3.score': -1, discoveredAt: 1 })
  .populate('deviceId', 'name ipAddress type');
};

// Static method to get vulnerabilities with exploits
vulnerabilitySchema.statics.getExploitable = function() {
  return this.find({
    exploitAvailable: true,
    status: { $in: ['open', 'in_progress'] }
  })
  .sort({ 'cvssV3.score': -1 })
  .populate('deviceId');
};

// Static method to get statistics
vulnerabilitySchema.statics.getStats = async function() {
  const stats = await this.aggregate([
    {
      $group: {
        _id: '$status',
        count: { $sum: 1 },
        avgCvss: { $avg: '$cvssV3.score' }
      }
    }
  ]);
  
  const bySeverity = await this.aggregate([
    {
      $group: {
        _id: '$severity',
        count: { $sum: 1 }
      }
    }
  ]);
  
  return { byStatus: stats, bySeverity };
};

// Instance method to acknowledge
vulnerabilitySchema.methods.acknowledge = async function(userId, notes) {
  this.status = 'in_progress';
  this.acknowledgedAt = new Date();
  if (notes) {
    this.notes.push({
      author: userId,
      content: notes,
      createdAt: new Date()
    });
  }
  return this.save();
};

// Instance method to resolve
vulnerabilitySchema.methods.resolve = async function(userId, notes) {
  this.status = 'resolved';
  this.resolvedAt = new Date();
  if (notes) {
    this.notes.push({
      author: userId,
      content: notes,
      createdAt: new Date()
    });
  }
  return this.save();
};

module.exports = mongoose.model('Vulnerability', vulnerabilitySchema);
