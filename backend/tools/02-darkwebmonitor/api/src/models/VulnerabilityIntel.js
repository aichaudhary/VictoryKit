const mongoose = require('mongoose');

/**
 * VulnerabilityIntel Model
 * Stores vulnerability intelligence including CVEs, exploits, and patches
 */
const VulnerabilityIntelSchema = new mongoose.Schema({
  // Vulnerability identification
  vulnId: {
    type: String,
    required: true,
    unique: true,
    index: true
  },

  cveId: {
    type: String,
    required: true,
    unique: true,
    index: true
  },

  // Vulnerability details
  title: String,

  description: {
    type: String,
    required: true
  },

  summary: String,

  // CVSS scoring
  cvss: {
    version: {
      type: String,
      enum: ['2.0', '3.0', '3.1'],
      default: '3.1'
    },
    baseScore: {
      type: Number,
      required: true,
      min: 0,
      max: 10,
      index: true
    },
    temporalScore: Number,
    environmentalScore: Number,
    vectorString: String,
    attackVector: {
      type: String,
      enum: ['NETWORK', 'ADJACENT_NETWORK', 'LOCAL', 'PHYSICAL']
    },
    attackComplexity: {
      type: String,
      enum: ['LOW', 'HIGH']
    },
    privilegesRequired: {
      type: String,
      enum: ['NONE', 'LOW', 'HIGH']
    },
    userInteraction: {
      type: String,
      enum: ['NONE', 'REQUIRED']
    },
    scope: {
      type: String,
      enum: ['UNCHANGED', 'CHANGED']
    },
    confidentialityImpact: {
      type: String,
      enum: ['NONE', 'LOW', 'HIGH']
    },
    integrityImpact: {
      type: String,
      enum: ['NONE', 'LOW', 'HIGH']
    },
    availabilityImpact: {
      type: String,
      enum: ['NONE', 'LOW', 'HIGH']
    }
  },

  // Severity classification
  severity: {
    type: String,
    enum: ['low', 'medium', 'high', 'critical'],
    required: true,
    index: true
  },

  // CWE (Common Weakness Enumeration)
  cwe: [{
    id: String,
    name: String,
    description: String
  }],

  // Affected products
  affectedProducts: [{
    vendor: String,
    product: String,
    versions: [String],
    configurations: [String],
    cpe: String // Common Platform Enumeration
  }],

  // Exploit information
  exploit: {
    exploitAvailable: {
      type: Boolean,
      default: false,
      index: true
    },
    exploitPublished: Date,
    exploitMaturity: {
      type: String,
      enum: ['unproven', 'proof_of_concept', 'functional', 'high', 'not_defined'],
      default: 'not_defined'
    },
    exploitedInWild: {
      type: Boolean,
      default: false,
      index: true
    },
    exploitKits: [String],
    publicExploits: [{
      title: String,
      author: String,
      url: String,
      publishedDate: Date,
      platform: String
    }],
    metasploitModules: [{
      name: String,
      path: String,
      rank: String
    }]
  },

  // Threat intelligence context
  threatContext: {
    activeExploitation: {
      type: Boolean,
      default: false
    },
    campaigns: [{
      campaignId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Campaign'
      },
      campaignName: String
    }],
    threatActors: [{
      actorId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'ThreatActor'
      },
      actorName: String
    }],
    associatedMalware: [String],
    targetedIndustries: [String],
    targetedCountries: [String]
  },

  // Patch and remediation
  patch: {
    patchAvailable: {
      type: Boolean,
      default: false,
      index: true
    },
    patchDate: Date,
    patchUrl: String,
    patchComplexity: {
      type: String,
      enum: ['low', 'medium', 'high']
    },
    vendorAdvisories: [{
      vendor: String,
      title: String,
      url: String,
      publishedDate: Date
    }],
    workarounds: [{
      description: String,
      effectiveness: String
    }]
  },

  // Remediation recommendations
  remediation: {
    priority: {
      type: String,
      enum: ['low', 'medium', 'high', 'critical'],
      default: 'medium'
    },
    timeline: String, // e.g., "immediate", "within 30 days", etc.
    recommendations: [String],
    mitigations: [{
      mitigation: String,
      effectiveness: String,
      implementation: String
    }],
    detectionMethods: [{
      method: String,
      description: String,
      tool: String
    }]
  },

  // Impact assessment
  impact: {
    businessImpact: {
      type: String,
      enum: ['low', 'medium', 'high', 'critical']
    },
    technicalImpact: {
      dataLoss: Boolean,
      dataModification: Boolean,
      serviceDisruption: Boolean,
      privilegeEscalation: Boolean,
      remoteCodeExecution: Boolean,
      informationDisclosure: Boolean
    },
    prevalence: {
      type: String,
      enum: ['rare', 'uncommon', 'common', 'widespread']
    },
    exploitabilityScore: Number // 0-100
  },

  // Detection
  detection: {
    signatures: [{
      ruleType: String,
      ruleName: String,
      rule: String
    }],
    iocs: [{
      iocId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'IOC'
      },
      iocType: String,
      iocValue: String
    }],
    huntingQueries: [{
      platform: String,
      query: String,
      description: String
    }]
  },

  // Timeline
  timeline: {
    published: {
      type: Date,
      required: true,
      index: true
    },
    disclosed: Date,
    discovered: Date,
    lastModified: Date,
    exploitPublished: Date,
    patchReleased: Date
  },

  // References
  references: [{
    source: String,
    url: String,
    tags: [String]
  }],

  // Intelligence sources
  sources: [{
    name: String,
    url: String,
    reportedAt: Date,
    reliability: String
  }],

  // Status
  status: {
    type: String,
    enum: ['new', 'analyzing', 'validated', 'patched', 'mitigated', 'archived'],
    default: 'new',
    index: true
  },

  // Risk assessment
  risk: {
    riskScore: {
      type: Number,
      min: 0,
      max: 100
    },
    riskLevel: {
      type: String,
      enum: ['low', 'medium', 'high', 'critical']
    },
    factors: {
      cvssScore: Number,
      exploitAvailable: Boolean,
      exploitedInWild: Boolean,
      patchAvailable: Boolean,
      assetExposure: Number,
      threatActorInterest: Number
    }
  },

  // Compliance impact
  compliance: {
    affectsCompliance: Boolean,
    standards: [{
      type: String,
      enum: ['PCI-DSS', 'HIPAA', 'SOC2', 'ISO27001', 'NIST', 'GDPR']
    }],
    requirements: [String]
  },

  // Analysis
  analysis: {
    overview: String,
    keyFindings: [String],
    relatedVulnerabilities: [{
      cveId: String,
      relationship: String
    }],
    analystNotes: [{
      analyst: String,
      note: String,
      createdAt: Date
    }]
  },

  // Sharing
  tlp: {
    type: String,
    enum: ['TLP:WHITE', 'TLP:GREEN', 'TLP:AMBER', 'TLP:RED'],
    default: 'TLP:WHITE'
  },

  // Tags
  tags: [String],

  // Custom fields
  customFields: mongoose.Schema.Types.Mixed

}, {
  timestamps: true,
  collection: 'vulnerabilityintel'
});

// Indexes
VulnerabilityIntelSchema.index({ vulnId: 1 });
VulnerabilityIntelSchema.index({ cveId: 1 });
VulnerabilityIntelSchema.index({ severity: 1, 'exploit.exploitAvailable': 1 });
VulnerabilityIntelSchema.index({ 'cvss.baseScore': -1 });
VulnerabilityIntelSchema.index({ 'timeline.published': -1 });
VulnerabilityIntelSchema.index({ status: 1 });

// Virtual: Age in days
VulnerabilityIntelSchema.virtual('ageInDays').get(function() {
  const diff = new Date() - this.timeline.published;
  return Math.floor(diff / (1000 * 60 * 60 * 24));
});

// Virtual: Has active threat
VulnerabilityIntelSchema.virtual('hasActiveThreat').get(function() {
  return this.exploit.exploitedInWild || 
         this.exploit.exploitAvailable || 
         this.threatContext.activeExploitation;
});

// Instance method: Calculate risk score
VulnerabilityIntelSchema.methods.calculateRiskScore = function() {
  let score = 0;
  
  // CVSS score (0-40 points)
  score += (this.cvss.baseScore / 10) * 40;
  
  // Exploit availability (0-25 points)
  if (this.exploit.exploitedInWild) score += 25;
  else if (this.exploit.exploitMaturity === 'high') score += 20;
  else if (this.exploit.exploitMaturity === 'functional') score += 15;
  else if (this.exploit.exploitMaturity === 'proof_of_concept') score += 10;
  else if (this.exploit.exploitAvailable) score += 5;
  
  // Patch availability (0-15 points, inverse)
  if (!this.patch.patchAvailable) score += 15;
  else if (this.patch.patchComplexity === 'high') score += 10;
  else if (this.patch.patchComplexity === 'medium') score += 5;
  
  // Active exploitation (0-10 points)
  if (this.threatContext.activeExploitation) score += 10;
  
  // Threat actor interest (0-10 points)
  if (this.threatContext.threatActors && this.threatContext.threatActors.length > 0) {
    score += Math.min(10, this.threatContext.threatActors.length * 3);
  }
  
  this.risk.riskScore = Math.min(100, Math.round(score));
  
  // Determine risk level
  if (this.risk.riskScore >= 90) this.risk.riskLevel = 'critical';
  else if (this.risk.riskScore >= 70) this.risk.riskLevel = 'high';
  else if (this.risk.riskScore >= 40) this.risk.riskLevel = 'medium';
  else this.risk.riskLevel = 'low';
  
  return this.risk.riskScore;
};

// Instance method: Add exploit information
VulnerabilityIntelSchema.methods.addExploit = function(exploitData) {
  this.exploit.exploitAvailable = true;
  this.exploit.exploitPublished = exploitData.publishedDate || new Date();
  
  if (exploitData.exploitMaturity) {
    this.exploit.exploitMaturity = exploitData.exploitMaturity;
  }
  
  if (exploitData.publicExploit) {
    this.exploit.publicExploits.push(exploitData.publicExploit);
  }
  
  // Recalculate risk score
  this.calculateRiskScore();
  
  return this.save();
};

// Instance method: Mark as patched
VulnerabilityIntelSchema.methods.markPatched = function(patchInfo) {
  this.patch.patchAvailable = true;
  this.patch.patchDate = patchInfo.patchDate || new Date();
  this.patch.patchUrl = patchInfo.patchUrl;
  this.status = 'patched';
  
  if (patchInfo.advisory) {
    this.patch.vendorAdvisories.push(patchInfo.advisory);
  }
  
  // Recalculate risk score
  this.calculateRiskScore();
  
  return this.save();
};

// Static: Find critical exploited vulnerabilities
VulnerabilityIntelSchema.statics.findCriticalExploited = function() {
  return this.find({
    severity: { $in: ['high', 'critical'] },
    'exploit.exploitedInWild': true,
    'patch.patchAvailable': false
  }).sort({ 'cvss.baseScore': -1 });
};

// Static: Find unpatched vulnerabilities
VulnerabilityIntelSchema.statics.findUnpatched = function(severity = null) {
  const query = {
    'patch.patchAvailable': false,
    status: { $ne: 'archived' }
  };
  
  if (severity) {
    query.severity = severity;
  }
  
  return this.find(query).sort({ 'cvss.baseScore': -1 });
};

// Static: Find by product
VulnerabilityIntelSchema.statics.findByProduct = function(vendor, product) {
  return this.find({
    'affectedProducts.vendor': vendor,
    'affectedProducts.product': product
  }).sort({ 'cvss.baseScore': -1 });
};

// Static: Get statistics
VulnerabilityIntelSchema.statics.getStatistics = async function() {
  return await this.aggregate([
    {
      $group: {
        _id: null,
        total: { $sum: 1 },
        critical: {
          $sum: { $cond: [{ $eq: ['$severity', 'critical'] }, 1, 0] }
        },
        exploited: {
          $sum: { $cond: ['$exploit.exploitedInWild', 1, 0] }
        },
        unpatched: {
          $sum: { $cond: ['$patch.patchAvailable', 0, 1] }
        },
        avgCvss: { $avg: '$cvss.baseScore' }
      }
    }
  ]);
};

// Pre-save: Calculate severity from CVSS
VulnerabilityIntelSchema.pre('save', function(next) {
  if (this.isModified('cvss.baseScore')) {
    const score = this.cvss.baseScore;
    if (score >= 9.0) this.severity = 'critical';
    else if (score >= 7.0) this.severity = 'high';
    else if (score >= 4.0) this.severity = 'medium';
    else this.severity = 'low';
    
    // Recalculate risk score
    this.calculateRiskScore();
  }
  
  next();
});

module.exports = mongoose.model('VulnerabilityIntel', VulnerabilityIntelSchema);
