const axios = require('axios');
const { ApiError } = require('../../../../shared/utils/apiError');

class MLService {
  constructor() {
    this.mlEngineUrl = process.env.ML_ENGINE_URL || 'http://localhost:8004';
  }

  async analyzeSample(sampleData) {
    try {
      const response = await axios.post(`${this.mlEngineUrl}/analyze`, sampleData, { timeout: 10000 });
      return response.data;
    } catch (error) {
      if (error.code === 'ECONNREFUSED') return this.ruleBasedAnalysis(sampleData);
      throw new ApiError(500, 'ML analysis failed: ' + error.message);
    }
  }

  async classifyMalware(features) {
    try {
      const response = await axios.post(`${this.mlEngineUrl}/classify`, features, { timeout: 5000 });
      return response.data;
    } catch (error) {
      return this.ruleBasedClassification(features);
    }
  }

  async detectFamily(fileHash) {
    try {
      const response = await axios.post(`${this.mlEngineUrl}/family`, { hash: fileHash }, { timeout: 3000 });
      return response.data;
    } catch (error) {
      return { family: 'unknown', confidence: 0 };
    }
  }

  ruleBasedAnalysis(data) {
    let malwareType = 'unknown', severity = 'MEDIUM', confidence = 60, isMalicious = false;

    // Check file characteristics
    if (data.fileType?.toLowerCase().includes('exe') || data.fileType?.toLowerCase().includes('dll')) {
      confidence += 10;
    }

    // Check entropy (high entropy often indicates packing/encryption)
    if (data.staticAnalysis?.entropy > 7.0) {
      isMalicious = true;
      severity = 'HIGH';
      confidence += 20;
    }

    // Check for suspicious imports
    const suspiciousImports = ['VirtualAlloc', 'WriteProcessMemory', 'CreateRemoteThread', 'LoadLibrary'];
    const hasS uspiciousImports = data.staticAnalysis?.imports?.some(imp => 
      suspiciousImports.some(s => imp.includes(s))
    );
    if (hasSuspiciousImports) {
      isMalicious = true;
      malwareType = 'trojan';
      confidence += 15;
    }

    // Check signatures
    if (data.signatures?.some(s => s.matched)) {
      isMalicious = true;
      severity = 'CRITICAL';
      confidence = 95;
      malwareType = data.signatures.find(s => s.matched)?.name.split('.')[0] || 'malware';
    }

    return {
      malwareType,
      severity,
      confidence: Math.min(confidence, 100),
      isMalicious,
      familyName: 'unknown',
      model: 'rule-based',
      timestamp: new Date()
    };
  }

  ruleBasedClassification(features) {
    let malwareType = 'unknown';
    
    if (features.behavior?.includes('encryption')) malwareType = 'ransomware';
    else if (features.behavior?.includes('keylogging')) malwareType = 'keylogger';
    else if (features.behavior?.includes('network')) malwareType = 'trojan';
    
    return { malwareType, confidence: 50, model: 'rule-based' };
  }

  async getModelMetrics() {
    try {
      const response = await axios.get(`${this.mlEngineUrl}/metrics`);
      return response.data;
    } catch (error) {
      return { status: 'unavailable' };
    }
  }
}

module.exports = new MLService();
