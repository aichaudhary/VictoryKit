const axios = require("axios");
const { ApiError } = require("../../../../../shared/utils/apiError");

class MLService {
  constructor() {
    this.mlEngineUrl = process.env.ML_ENGINE_URL || "http://localhost:8004";
  }

  async analyzeSample(sampleData) {
    try {
      const response = await axios.post(
        `${this.mlEngineUrl}/analyze`,
        sampleData,
        { timeout: 10000 }
      );
      return response.data;
    } catch (error) {
      if (error.code === "ECONNREFUSED")
        return this.ruleBasedAnalysis(sampleData);
      throw new ApiError(500, "ML analysis failed: " + error.message);
    }
  }

  async classifyMalware(features) {
    try {
      const response = await axios.post(
        `${this.mlEngineUrl}/classify`,
        features,
        { timeout: 5000 }
      );
      return response.data;
    } catch (error) {
      return this.ruleBasedClassification(features);
    }
  }

  async detectFamily(fileHash) {
    try {
      const response = await axios.post(
        `${this.mlEngineUrl}/family`,
        { hash: fileHash },
        { timeout: 3000 }
      );
      return response.data;
    } catch (error) {
      return { family: "unknown", confidence: 0 };
    }
  }

  ruleBasedAnalysis(data) {
    let malwareType = "unknown",
      severity = "MEDIUM",
      confidence = 60,
      isMalicious = false;

    // Check file characteristics
    if (
      data.fileType?.toLowerCase().includes("exe") ||
      data.fileType?.toLowerCase().includes("dll")
    ) {
      confidence += 10;
    }

    // Check entropy (high entropy often indicates packing/encryption)
    if (data.staticAnalysis?.entropy > 7.0) {
      isMalicious = true;
      severity = "HIGH";
      confidence += 20;
    }

    // Check for suspicious imports
    const suspiciousImports = [
      "VirtualAlloc",
      "WriteProcessMemory",
      "CreateRemoteThread",
      "LoadLibrary",
    ];
    const hasSuspiciousImports = data.staticAnalysis?.imports?.some((imp) =>
      suspiciousImports.some((s) => imp.includes(s))
    );
    if (hasSuspiciousImports) {
      isMalicious = true;
      malwareType = "trojan";
      confidence += 15;
    }

    // Check signatures
    if (data.signatures?.some((s) => s.matched)) {
      isMalicious = true;
      severity = "CRITICAL";
      confidence = 95;
      malwareType =
        data.signatures.find((s) => s.matched)?.name.split(".")[0] || "malware";
    }

    return {
      malwareType,
      severity,
      confidence: Math.min(confidence, 100),
      isMalicious,
      familyName: "unknown",
      model: "rule-based",
      timestamp: new Date(),
    };
  }

  ruleBasedClassification(features) {
    let malwareType = "unknown";

    if (features.behavior?.includes("encryption")) malwareType = "ransomware";
    else if (features.behavior?.includes("keylogging"))
      malwareType = "keylogger";
    else if (features.behavior?.includes("network")) malwareType = "trojan";

    return { malwareType, confidence: 50, model: "rule-based" };
  }
  /**
   * Integrate with external security systems when malware is detected
   */
  async handleMalwareDetection(sample, analysisResult) {
    const { getToolConnectors, getToolActions } = require('../../../../../shared/connectors/ToolConnectorMapping');
    const connectors = getToolConnectors('malwarehunter');

    const actions = [];

    // Microsoft Sentinel integration
    if (connectors.includes('sentinel')) {
      try {
        const sentinelActions = getToolActions('malwarehunter', 'sentinel');
        if (sentinelActions.ingestEvents) {
          await this.ingestToSentinel(sample, analysisResult);
          actions.push('sentinel:ingest');
        }
        if (sentinelActions.createIncidents && analysisResult.severity === 'CRITICAL') {
          await this.createSentinelIncident(sample, analysisResult);
          actions.push('sentinel:incident');
        }
      } catch (error) {
        console.error('Sentinel integration failed:', error.message);
      }
    }

    // Cortex XSOAR integration
    if (connectors.includes('cortexXSOAR')) {
      try {
        const soarActions = getToolActions('malwarehunter', 'cortexXSOAR');
        if (soarActions.createIncidents) {
          await this.createXSOARIncident(sample, analysisResult);
          actions.push('xsoar:incident');
        }
        if (soarActions.executePlaybooks) {
          await this.executeMalwarePlaybook(sample, analysisResult);
          actions.push('xsoar:playbook');
        }
      } catch (error) {
        console.error('XSOAR integration failed:', error.message);
      }
    }

    // CrowdStrike integration
    if (connectors.includes('crowdstrike')) {
      try {
        const csActions = getToolActions('malwarehunter', 'crowdstrike');
        if (csActions.createIOCs && analysisResult.confidence > 0.8) {
          await this.createCrowdStrikeIOC(sample, analysisResult);
          actions.push('crowdstrike:ioc');
        }
      } catch (error) {
        console.error('CrowdStrike integration failed:', error.message);
      }
    }

    // OpenCTI integration
    if (connectors.includes('opencti')) {
      try {
        const tiActions = getToolActions('malwarehunter', 'opencti');
        if (tiActions.createIndicators) {
          await this.createOpenCTIIndicator(sample, analysisResult);
          actions.push('opencti:indicator');
        }
      } catch (error) {
        console.error('OpenCTI integration failed:', error.message);
      }
    }

    return actions;
  }

  /**
   * Ingest malware detection to Microsoft Sentinel
   */
  async ingestToSentinel(sample, analysisResult) {
    const { registry } = require('../../../../../shared/connectors');
    const sentinel = registry.get('sentinel');

    if (!sentinel) return;

    const eventData = {
      TimeGenerated: new Date().toISOString(),
      SourceSystem: 'VictoryKit',
      ToolName: 'MalwareHunter',
      SampleId: sample.id,
      FileName: sample.filename,
      FileHash: sample.hash,
      FileSize: sample.size,
      MalwareType: analysisResult.malwareType,
      Severity: analysisResult.severity,
      Confidence: analysisResult.confidence,
      DetectionEngine: 'AI_ML_Engine',
      UserId: sample.userId
    };

    await sentinel.ingestData('MalwareDetections', [eventData]);
  }

  /**
   * Create Sentinel incident for critical malware
   */
  async createSentinelIncident(sample, analysisResult) {
    const { registry } = require('../../../../../shared/connectors');
    const sentinel = registry.get('sentinel');

    if (!sentinel) return;

    const incidentData = {
      id: `MALWARE-${sample.id}-${Date.now()}`,
      title: `Critical Malware Detected: ${analysisResult.malwareType}`,
      description: `MalwareHunter detected ${analysisResult.malwareType} in file ${sample.filename} with ${analysisResult.confidence * 100}% confidence.`,
      severity: this.mapSeverityToSentinel(analysisResult.severity),
      status: 'New',
      labels: [
        { labelName: 'Tool', labelValue: 'MalwareHunter' },
        { labelName: 'MalwareType', labelValue: analysisResult.malwareType },
        { labelName: 'Severity', labelValue: analysisResult.severity }
      ],
      firstActivityTimeUtc: sample.uploadedAt,
      lastActivityTimeUtc: new Date().toISOString()
    };

    await sentinel.createIncident(incidentData);
  }

  /**
   * Create Cortex XSOAR incident
   */
  async createXSOARIncident(sample, analysisResult) {
    const { registry } = require('../../../../../shared/connectors');
    const xsoar = registry.get('cortexXSOAR');

    if (!xsoar) return;

    const incidentData = {
      name: `MalwareHunter: ${analysisResult.malwareType} Detected`,
      type: 'Malware',
      severity: this.mapSeverityToXSOAR(analysisResult.severity),
      details: `File: ${sample.filename}\nHash: ${sample.hash}\nConfidence: ${(analysisResult.confidence * 100).toFixed(1)}%`,
      occurred: new Date().toISOString(),
      labels: [
        { type: 'Tool', value: 'MalwareHunter' },
        { type: 'MalwareType', value: analysisResult.malwareType }
      ],
      customFields: {
        file_hash: sample.hash,
        file_name: sample.filename,
        detection_confidence: analysisResult.confidence,
        malware_family: analysisResult.malwareType
      }
    };

    await xsoar.createIncident(incidentData);
  }

  /**
   * Execute malware response playbook in XSOAR
   */
  async executeMalwarePlaybook(sample, analysisResult) {
    const { registry } = require('../../../../../shared/connectors');
    const xsoar = registry.get('cortexXSOAR');

    if (!xsoar) return;

    const inputs = {
      file_hash: sample.hash,
      file_name: sample.filename,
      malware_type: analysisResult.malwareType,
      severity: analysisResult.severity,
      confidence: analysisResult.confidence,
      user_id: sample.userId
    };

    await xsoar.executePlaybook('malware-response', inputs);
  }

  /**
   * Create IOC in CrowdStrike
   */
  async createCrowdStrikeIOC(sample, analysisResult) {
    const { registry } = require('../../../../../shared/connectors');
    const crowdstrike = registry.get('crowdstrike');

    if (!crowdstrike) return;

    const iocData = {
      type: 'hash',
      value: sample.hash,
      action: 'detect',
      severity: this.mapSeverityToCrowdStrike(analysisResult.severity),
      platforms: ['windows', 'mac', 'linux'],
      description: `MalwareHunter detected ${analysisResult.malwareType}`,
      tags: ['VictoryKit', 'MalwareHunter', analysisResult.malwareType]
    };

    await crowdstrike.createIOC(iocData);
  }

  /**
   * Create threat indicator in OpenCTI
   */
  async createOpenCTIIndicator(sample, analysisResult) {
    const { registry } = require('../../../../../shared/connectors');
    const opencti = registry.get('opencti');

    if (!opencti) return;

    const indicatorData = {
      pattern: `[file:hashes.MD5 = '${sample.hash}']`,
      patternType: 'stix',
      labels: ['malware', analysisResult.malwareType.toLowerCase()],
      description: `MalwareHunter detected ${analysisResult.malwareType} with ${(analysisResult.confidence * 100).toFixed(1)}% confidence`,
      confidence: Math.round(analysisResult.confidence * 100),
      createdByRef: 'VictoryKit MalwareHunter',
      objectMarkingsRefs: ['TLP:AMBER']
    };

    await opencti.createIndicator(indicatorData);
  }

  /**
   * Severity mapping helpers
   */
  mapSeverityToSentinel(severity) {
    const mapping = {
      'CRITICAL': 'High',
      'HIGH': 'High',
      'MEDIUM': 'Medium',
      'LOW': 'Low'
    };
    return mapping[severity] || 'Medium';
  }

  mapSeverityToXSOAR(severity) {
    const mapping = {
      'CRITICAL': 4,
      'HIGH': 3,
      'MEDIUM': 2,
      'LOW': 1
    };
    return mapping[severity] || 2;
  }

  mapSeverityToCrowdStrike(severity) {
    const mapping = {
      'CRITICAL': 'high',
      'HIGH': 'high',
      'MEDIUM': 'medium',
      'LOW': 'low'
    };
    return mapping[severity] || 'medium';
  }
  async getModelMetrics() {
    try {
      const response = await axios.get(`${this.mlEngineUrl}/metrics`);
      return response.data;
    } catch (error) {
      return { status: "unavailable" };
    }
  }
}

module.exports = new MLService();
