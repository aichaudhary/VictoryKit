const axios = require('axios');

/**
 * ThreatIntel Service - Real-time threat intelligence integrations
 * Integrates with VirusTotal, Hybrid Analysis, MalwareBazaar, Intezer, and more
 */
class ThreatIntelService {
  constructor() {
    this.cache = new Map();
    this.cacheTimeout = 10 * 60 * 1000; // 10 minutes
  }

  // ============================================
  // VIRUSTOTAL INTEGRATION (70+ AV Engines)
  // ============================================

  /**
   * Scan file hash with VirusTotal
   * Free tier: 4 requests/min, 500/day
   */
  async virusTotalHashLookup(hash) {
    const apiKey = process.env.VIRUSTOTAL_API_KEY;
    if (!apiKey || apiKey === 'YOUR_VIRUSTOTAL_API_KEY') {
      return { source: 'VirusTotal', error: 'API key not configured', data: null };
    }

    try {
      const response = await axios.get(
        `https://www.virustotal.com/api/v3/files/${hash}`,
        {
          headers: { 'x-apikey': apiKey },
          timeout: 15000
        }
      );

      const data = response.data.data;
      const stats = data.attributes.last_analysis_stats;
      
      return {
        source: 'VirusTotal',
        hash: hash,
        detectionRate: `${stats.malicious}/${stats.malicious + stats.undetected}`,
        malicious: stats.malicious,
        suspicious: stats.suspicious,
        undetected: stats.undetected,
        harmless: stats.harmless,
        verdict: stats.malicious > 0 ? 'MALICIOUS' : 'CLEAN',
        names: data.attributes.names?.slice(0, 5) || [],
        type: data.attributes.type_description,
        size: data.attributes.size,
        firstSubmission: data.attributes.first_submission_date,
        lastAnalysis: data.attributes.last_analysis_date,
        tags: data.attributes.tags?.slice(0, 10) || [],
        engines: Object.entries(data.attributes.last_analysis_results || {})
          .filter(([_, r]) => r.category === 'malicious')
          .map(([name, r]) => ({ engine: name, result: r.result }))
          .slice(0, 20),
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      if (error.response?.status === 404) {
        return { source: 'VirusTotal', hash, verdict: 'NOT_FOUND', message: 'Hash not in database' };
      }
      console.error('VirusTotal lookup error:', error.message);
      return { source: 'VirusTotal', error: error.message, data: null };
    }
  }

  /**
   * Upload file to VirusTotal for scanning
   */
  async virusTotalUpload(fileBuffer, fileName) {
    const apiKey = process.env.VIRUSTOTAL_API_KEY;
    if (!apiKey || apiKey === 'YOUR_VIRUSTOTAL_API_KEY') {
      return { source: 'VirusTotal', error: 'API key not configured', data: null };
    }

    try {
      const FormData = require('form-data');
      const form = new FormData();
      form.append('file', fileBuffer, { filename: fileName });

      const response = await axios.post(
        'https://www.virustotal.com/api/v3/files',
        form,
        {
          headers: {
            'x-apikey': apiKey,
            ...form.getHeaders()
          },
          timeout: 60000
        }
      );

      return {
        source: 'VirusTotal',
        analysisId: response.data.data.id,
        status: 'queued',
        message: 'File submitted for analysis',
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error('VirusTotal upload error:', error.message);
      return { source: 'VirusTotal', error: error.message, data: null };
    }
  }

  /**
   * Get analysis status from VirusTotal
   */
  async virusTotalGetAnalysis(analysisId) {
    const apiKey = process.env.VIRUSTOTAL_API_KEY;
    if (!apiKey || apiKey === 'YOUR_VIRUSTOTAL_API_KEY') {
      return { source: 'VirusTotal', error: 'API key not configured', data: null };
    }

    try {
      const response = await axios.get(
        `https://www.virustotal.com/api/v3/analyses/${analysisId}`,
        {
          headers: { 'x-apikey': apiKey },
          timeout: 10000
        }
      );

      const data = response.data.data;
      return {
        source: 'VirusTotal',
        analysisId,
        status: data.attributes.status,
        stats: data.attributes.stats,
        results: data.attributes.results,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error('VirusTotal analysis error:', error.message);
      return { source: 'VirusTotal', error: error.message, data: null };
    }
  }

  // ============================================
  // HYBRID ANALYSIS / FALCON SANDBOX
  // ============================================

  /**
   * Submit file to Hybrid Analysis for sandbox execution
   * Free tier available with registration
   */
  async hybridAnalysisSubmit(fileBuffer, fileName, environmentId = 120) {
    const apiKey = process.env.HYBRID_ANALYSIS_API_KEY;
    if (!apiKey || apiKey === 'YOUR_HYBRID_ANALYSIS_API_KEY') {
      return { source: 'HybridAnalysis', error: 'API key not configured', data: null };
    }

    try {
      const FormData = require('form-data');
      const form = new FormData();
      form.append('file', fileBuffer, { filename: fileName });
      form.append('environment_id', environmentId.toString()); // 120 = Windows 7 64-bit

      const response = await axios.post(
        'https://www.hybrid-analysis.com/api/v2/submit/file',
        form,
        {
          headers: {
            'api-key': apiKey,
            'user-agent': 'Falcon Sandbox',
            ...form.getHeaders()
          },
          timeout: 60000
        }
      );

      return {
        source: 'HybridAnalysis',
        jobId: response.data.job_id,
        sha256: response.data.sha256,
        submissionId: response.data.submission_id,
        environmentId,
        status: 'submitted',
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error('Hybrid Analysis submit error:', error.message);
      return { source: 'HybridAnalysis', error: error.message, data: null };
    }
  }

  /**
   * Get report from Hybrid Analysis
   */
  async hybridAnalysisReport(sha256) {
    const apiKey = process.env.HYBRID_ANALYSIS_API_KEY;
    if (!apiKey || apiKey === 'YOUR_HYBRID_ANALYSIS_API_KEY') {
      return { source: 'HybridAnalysis', error: 'API key not configured', data: null };
    }

    try {
      const response = await axios.get(
        `https://www.hybrid-analysis.com/api/v2/report/${sha256}/summary`,
        {
          headers: {
            'api-key': apiKey,
            'user-agent': 'Falcon Sandbox'
          },
          timeout: 15000
        }
      );

      const data = response.data;
      return {
        source: 'HybridAnalysis',
        sha256,
        verdict: data.verdict,
        threatScore: data.threat_score,
        threatLevel: data.threat_level,
        malwareFamily: data.vx_family,
        tags: data.tags,
        processTree: data.process_tree,
        networkAnalysis: {
          hosts: data.hosts,
          domains: data.domains,
          httpRequests: data.http_requests?.length || 0
        },
        fileOperations: data.file_operations?.length || 0,
        registryOperations: data.registry_operations?.length || 0,
        mitreTechniques: data.mitre_attcks,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error('Hybrid Analysis report error:', error.message);
      return { source: 'HybridAnalysis', error: error.message, data: null };
    }
  }

  /**
   * Quick hash lookup in Hybrid Analysis
   */
  async hybridAnalysisHashLookup(hash) {
    const apiKey = process.env.HYBRID_ANALYSIS_API_KEY;
    if (!apiKey || apiKey === 'YOUR_HYBRID_ANALYSIS_API_KEY') {
      return { source: 'HybridAnalysis', error: 'API key not configured', data: null };
    }

    try {
      const response = await axios.post(
        'https://www.hybrid-analysis.com/api/v2/search/hash',
        `hash=${hash}`,
        {
          headers: {
            'api-key': apiKey,
            'user-agent': 'Falcon Sandbox',
            'Content-Type': 'application/x-www-form-urlencoded'
          },
          timeout: 10000
        }
      );

      if (response.data.length === 0) {
        return { source: 'HybridAnalysis', hash, verdict: 'NOT_FOUND' };
      }

      const latest = response.data[0];
      return {
        source: 'HybridAnalysis',
        hash,
        verdict: latest.verdict,
        threatScore: latest.threat_score,
        malwareFamily: latest.vx_family,
        type: latest.type,
        environment: latest.environment_description,
        analysisDate: latest.analysis_start_time,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error('Hybrid Analysis hash lookup error:', error.message);
      return { source: 'HybridAnalysis', error: error.message, data: null };
    }
  }

  // ============================================
  // MALWAREBAZAAR (Free - No API Key)
  // ============================================

  /**
   * Query MalwareBazaar for hash
   */
  async malwareBazaarLookup(hash) {
    try {
      const params = new URLSearchParams();
      params.append('query', 'get_info');
      params.append('hash', hash);

      const response = await axios.post(
        'https://mb-api.abuse.ch/api/v1/',
        params.toString(),
        {
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          timeout: 10000
        }
      );

      if (response.data.query_status === 'hash_not_found') {
        return { source: 'MalwareBazaar', hash, verdict: 'NOT_FOUND' };
      }

      if (response.data.query_status === 'ok') {
        const data = response.data.data[0];
        return {
          source: 'MalwareBazaar',
          hash,
          verdict: 'MALICIOUS',
          sha256: data.sha256_hash,
          sha1: data.sha1_hash,
          md5: data.md5_hash,
          fileName: data.file_name,
          fileType: data.file_type_mime,
          fileSize: data.file_size,
          signature: data.signature,
          malwareFamily: data.signature,
          firstSeen: data.first_seen,
          lastSeen: data.last_seen,
          reporter: data.reporter,
          tags: data.tags,
          intelligence: data.intelligence,
          timestamp: new Date().toISOString()
        };
      }

      return { source: 'MalwareBazaar', hash, error: response.data.query_status };
    } catch (error) {
      console.error('MalwareBazaar lookup error:', error.message);
      return { source: 'MalwareBazaar', error: error.message, data: null };
    }
  }

  /**
   * Get recent malware samples from MalwareBazaar
   */
  async malwareBazaarRecent(limit = 50) {
    try {
      const response = await axios.get(
        'https://bazaar.abuse.ch/export/txt/sha256/recent/',
        { timeout: 15000 }
      );

      const lines = response.data.split('\n')
        .filter(l => l && !l.startsWith('#') && l.length === 64)
        .slice(0, limit);

      return {
        source: 'MalwareBazaar',
        type: 'recent_samples',
        count: lines.length,
        hashes: lines,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error('MalwareBazaar recent error:', error.message);
      return { source: 'MalwareBazaar', error: error.message, data: null };
    }
  }

  // ============================================
  // ANY.RUN INTERACTIVE SANDBOX
  // ============================================

  /**
   * Submit task to ANY.RUN
   * Paid API
   */
  async anyRunSubmit(fileUrl, fileName) {
    const apiKey = process.env.ANYRUN_API_KEY;
    if (!apiKey || apiKey === 'YOUR_ANYRUN_API_KEY') {
      return { source: 'ANY.RUN', error: 'API key not configured', data: null };
    }

    try {
      const response = await axios.post(
        'https://api.any.run/v1/analysis',
        {
          file: fileUrl,
          env_os: 'Windows 10',
          env_bitness: 64,
          env_version: '21H2'
        },
        {
          headers: { 'Authorization': `API-Key ${apiKey}` },
          timeout: 30000
        }
      );

      return {
        source: 'ANY.RUN',
        taskId: response.data.data.taskid,
        status: 'submitted',
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error('ANY.RUN submit error:', error.message);
      return { source: 'ANY.RUN', error: error.message, data: null };
    }
  }

  /**
   * Get task report from ANY.RUN
   */
  async anyRunReport(taskId) {
    const apiKey = process.env.ANYRUN_API_KEY;
    if (!apiKey || apiKey === 'YOUR_ANYRUN_API_KEY') {
      return { source: 'ANY.RUN', error: 'API key not configured', data: null };
    }

    try {
      const response = await axios.get(
        `https://api.any.run/v1/analysis/${taskId}`,
        {
          headers: { 'Authorization': `API-Key ${apiKey}` },
          timeout: 15000
        }
      );

      const data = response.data.data;
      return {
        source: 'ANY.RUN',
        taskId,
        verdict: data.analysis.scores.verdict.verdict,
        threatLevel: data.analysis.scores.verdict.threatLevelText,
        threatScore: data.analysis.scores.verdict.threatLevel,
        malwareFamily: data.analysis.tags?.find(t => t.source === 'family')?.tag,
        processes: data.analysis.content.processes?.length || 0,
        networkConnections: data.analysis.content.network?.connections?.length || 0,
        httpRequests: data.analysis.content.network?.httpRequests?.length || 0,
        droppedFiles: data.analysis.content.files?.length || 0,
        mitreTechniques: data.analysis.mitre,
        iocs: data.analysis.iocs,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error('ANY.RUN report error:', error.message);
      return { source: 'ANY.RUN', error: error.message, data: null };
    }
  }

  // ============================================
  // INTEZER ANALYZE (Genetic Analysis)
  // ============================================

  /**
   * Analyze file with Intezer
   * Free tier available
   */
  async intezerAnalyze(sha256) {
    const apiKey = process.env.INTEZER_API_KEY;
    if (!apiKey || apiKey === 'YOUR_INTEZER_API_KEY') {
      return { source: 'Intezer', error: 'API key not configured', data: null };
    }

    try {
      // First get access token
      const tokenResponse = await axios.post(
        'https://analyze.intezer.com/api/v2-0/get-access-token',
        { api_key: apiKey },
        { timeout: 10000 }
      );
      const token = tokenResponse.data.result;

      // Get analysis
      const response = await axios.get(
        `https://analyze.intezer.com/api/v2-0/files/${sha256}`,
        {
          headers: { 'Authorization': `Bearer ${token}` },
          timeout: 15000
        }
      );

      const data = response.data.result;
      return {
        source: 'Intezer',
        sha256,
        verdict: data.verdict,
        subVerdict: data.sub_verdict,
        familyName: data.family_name,
        familyType: data.family_type,
        geneCount: data.gene_count,
        iocCount: data.ioc_count,
        codeReuse: data.code_reuse?.families || [],
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      if (error.response?.status === 404) {
        return { source: 'Intezer', sha256, verdict: 'NOT_FOUND' };
      }
      console.error('Intezer analyze error:', error.message);
      return { source: 'Intezer', error: error.message, data: null };
    }
  }

  // ============================================
  // JOE SANDBOX
  // ============================================

  /**
   * Submit file to Joe Sandbox
   * Paid API
   */
  async joeSandboxSubmit(fileBuffer, fileName) {
    const apiKey = process.env.JOE_SANDBOX_API_KEY;
    if (!apiKey || apiKey === 'YOUR_JOE_SANDBOX_API_KEY') {
      return { source: 'JoeSandbox', error: 'API key not configured', data: null };
    }

    try {
      const FormData = require('form-data');
      const form = new FormData();
      form.append('apikey', apiKey);
      form.append('file', fileBuffer, { filename: fileName });
      form.append('accept-tac', '1');

      const response = await axios.post(
        'https://jbxcloud.joesecurity.org/api/v2/submission/new',
        form,
        {
          headers: form.getHeaders(),
          timeout: 60000
        }
      );

      return {
        source: 'JoeSandbox',
        webId: response.data.data.webid,
        submissionId: response.data.data.submission_id,
        status: 'submitted',
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error('Joe Sandbox submit error:', error.message);
      return { source: 'JoeSandbox', error: error.message, data: null };
    }
  }

  /**
   * Get report from Joe Sandbox
   */
  async joeSandboxReport(webId) {
    const apiKey = process.env.JOE_SANDBOX_API_KEY;
    if (!apiKey || apiKey === 'YOUR_JOE_SANDBOX_API_KEY') {
      return { source: 'JoeSandbox', error: 'API key not configured', data: null };
    }

    try {
      const response = await axios.post(
        'https://jbxcloud.joesecurity.org/api/v2/analysis/info',
        { apikey: apiKey, webid: webId },
        { timeout: 15000 }
      );

      const data = response.data.data;
      return {
        source: 'JoeSandbox',
        webId,
        status: data.status,
        detection: data.detection,
        score: data.score,
        malwareFamily: data.malwarefamily,
        tags: data.tags,
        mitreTechniques: data.mitre,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error('Joe Sandbox report error:', error.message);
      return { source: 'JoeSandbox', error: error.message, data: null };
    }
  }

  // ============================================
  // COMPREHENSIVE LOOKUP
  // ============================================

  /**
   * Check hash against all configured services
   */
  async comprehensiveHashLookup(hash) {
    const results = {
      hash,
      timestamp: new Date().toISOString(),
      sources: {}
    };

    // Run all lookups in parallel
    const [vt, ha, mb, intezer] = await Promise.all([
      this.virusTotalHashLookup(hash),
      this.hybridAnalysisHashLookup(hash),
      this.malwareBazaarLookup(hash),
      this.intezerAnalyze(hash)
    ]);

    results.sources.virusTotal = vt;
    results.sources.hybridAnalysis = ha;
    results.sources.malwareBazaar = mb;
    results.sources.intezer = intezer;

    // Calculate consensus
    let maliciousCount = 0;
    let cleanCount = 0;
    let notFoundCount = 0;

    [vt, ha, mb, intezer].forEach(r => {
      if (r.verdict === 'MALICIOUS' || r.verdict === 'malicious') maliciousCount++;
      else if (r.verdict === 'CLEAN' || r.verdict === 'no_threat') cleanCount++;
      else if (r.verdict === 'NOT_FOUND') notFoundCount++;
    });

    results.consensus = {
      maliciousVotes: maliciousCount,
      cleanVotes: cleanCount,
      notFoundVotes: notFoundCount,
      verdict: maliciousCount > 0 ? 'MALICIOUS' : cleanCount > 0 ? 'CLEAN' : 'UNKNOWN',
      confidence: maliciousCount >= 2 ? 'HIGH' : maliciousCount === 1 ? 'MEDIUM' : 'LOW'
    };

    return results;
  }

  /**
   * Get API configuration status
   */
  getApiStatus() {
    return {
      virusTotal: !!(process.env.VIRUSTOTAL_API_KEY && process.env.VIRUSTOTAL_API_KEY !== 'YOUR_VIRUSTOTAL_API_KEY'),
      hybridAnalysis: !!(process.env.HYBRID_ANALYSIS_API_KEY && process.env.HYBRID_ANALYSIS_API_KEY !== 'YOUR_HYBRID_ANALYSIS_API_KEY'),
      malwareBazaar: true, // No API key needed
      anyRun: !!(process.env.ANYRUN_API_KEY && process.env.ANYRUN_API_KEY !== 'YOUR_ANYRUN_API_KEY'),
      intezer: !!(process.env.INTEZER_API_KEY && process.env.INTEZER_API_KEY !== 'YOUR_INTEZER_API_KEY'),
      joeSandbox: !!(process.env.JOE_SANDBOX_API_KEY && process.env.JOE_SANDBOX_API_KEY !== 'YOUR_JOE_SANDBOX_API_KEY')
    };
  }
}

module.exports = new ThreatIntelService();
