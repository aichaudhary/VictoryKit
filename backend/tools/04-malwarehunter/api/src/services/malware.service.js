const crypto = require('crypto');
const MalwareSample = require('../models/Sample.model');

class MalwareService {
  calculateHashes(buffer) {
    return {
      md5: crypto.createHash('md5').update(buffer).digest('hex'),
      sha1: crypto.createHash('sha1').update(buffer).digest('hex'),
      sha256: crypto.createHash('sha256').update(buffer).digest('hex')
    };
  }

  calculateEntropy(data) {
    const freq = {};
    for (let i = 0; i < data.length; i++) {
      freq[data[i]] = (freq[data[i]] || 0) + 1;
    }

    let entropy = 0;
    const len = data.length;
    for (const count of Object.values(freq)) {
      const p = count / len;
      entropy -= p * Math.log2(p);
    }

    return entropy;
  }

  determineSeverity(sample) {
    if (sample.malwareType === 'ransomware' || sample.malwareType === 'rootkit') {
      return 'CRITICAL';
    }
    if (sample.malwareType === 'trojan' || sample.malwareType === 'backdoor') {
      return 'HIGH';
    }
    if (sample.malwareType === 'worm' || sample.malwareType === 'virus') {
      return 'MEDIUM';
    }
    return 'LOW';
  }

  async performStaticAnalysis(fileData) {
    const analysis = {
      entropy: this.calculateEntropy(fileData),
      suspicious: [],
      strings: this.extractStrings(fileData),
      imports: [],
      exports: []
    };

    // Check entropy
    if (analysis.entropy > 7.0) {
      analysis.suspicious.push('High entropy - possible packing/encryption');
    }

    // Check for suspicious strings
    const suspiciousPatterns = ['cmd.exe', 'powershell', 'reg.exe', 'admin', 'password'];
    analysis.strings.forEach(str => {
      if (suspiciousPatterns.some(p => str.toLowerCase().includes(p))) {
        analysis.suspicious.push(`Suspicious string: ${str}`);
      }
    });

    return analysis;
  }

  extractStrings(buffer, minLength = 4) {
    const strings = [];
    let currentString = '';

    for (let i = 0; i < buffer.length; i++) {
      const char = buffer[i];
      if (char >= 32 && char <= 126) {
        currentString += String.fromCharCode(char);
      } else {
        if (currentString.length >= minLength) {
          strings.push(currentString);
        }
        currentString = '';
      }
    }

    return strings.slice(0, 100); // Limit to first 100 strings
  }

  generateInsights(samples) {
    const insights = [];

    const maliciousCount = samples.filter(s => s.isMalicious).length;
    const criticalCount = samples.filter(s => s.severity === 'CRITICAL').length;

    if (criticalCount > 0) {
      insights.push({
        type: 'critical_malware',
        title: 'Critical Malware Detected',
        description: `${criticalCount} critical severity malware samples detected`,
        severity: 'CRITICAL',
        affectedSamples: criticalCount,
        recommendations: [
          'Isolate affected systems immediately',
          'Initiate incident response procedures',
          'Perform full system scan on all endpoints'
        ]
      });
    }

    if (maliciousCount > samples.length * 0.5) {
      insights.push({
        type: 'high_infection_rate',
        title: 'High Malware Detection Rate',
        description: `${((maliciousCount / samples.length) * 100).toFixed(1)}% of samples are malicious`,
        severity: 'HIGH',
        affectedSamples: maliciousCount,
        recommendations: [
          'Review security controls',
          'Update antivirus signatures',
          'Conduct security awareness training'
        ]
      });
    }

    // Detect ransomware
    const ransomwareCount = samples.filter(s => s.malwareType === 'ransomware').length;
    if (ransomwareCount > 0) {
      insights.push({
        type: 'ransomware_detected',
        title: 'Ransomware Threat',
        description: `${ransomwareCount} ransomware samples detected`,
        severity: 'CRITICAL',
        affectedSamples: ransomwareCount,
        recommendations: [
          'Verify backup integrity',
          'Isolate critical systems',
          'Do not pay ransom',
          'Contact law enforcement'
        ]
      });
    }

    return insights;
  }

  async calculateStatistics(userId, timeRange) {
    const query = { userId };
    if (timeRange) query.uploadedAt = { $gte: timeRange.start, $lte: timeRange.end };

    const stats = await MalwareSample.aggregate([
      { $match: query },
      {
        $group: {
          _id: null,
          totalSamples: { $sum: 1 },
          maliciousSamples: { $sum: { $cond: ['$isMalicious', 1, 0] } },
          cleanSamples: { $sum: { $cond: [{ $not: '$isMalicious' }, 1, 0] } },
          criticalThreats: { $sum: { $cond: [{ $eq: ['$severity', 'CRITICAL'] }, 1, 0] } },
          highThreats: { $sum: { $cond: [{ $eq: ['$severity', 'HIGH'] }, 1, 0] } },
          mediumThreats: { $sum: { $cond: [{ $eq: ['$severity', 'MEDIUM'] }, 1, 0] } },
          lowThreats: { $sum: { $cond: [{ $eq: ['$severity', 'LOW'] }, 1, 0] } },
          avgConfidence: { $avg: '$confidence' }
        }
      }
    ]);

    return stats[0] || {
      totalSamples: 0,
      maliciousSamples: 0,
      cleanSamples: 0,
      criticalThreats: 0,
      highThreats: 0,
      mediumThreats: 0,
      lowThreats: 0,
      avgConfidence: 0
    };
  }
}

module.exports = new MalwareService();
