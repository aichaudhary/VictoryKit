/**
 * YARA Rules Service
 * Pattern matching for malware detection using YARA-like rules
 * Since YARA binary is not always available, we implement JS-based pattern matching
 */
class YaraService {
  constructor() {
    // Built-in YARA-like rules for common malware patterns
    this.rules = this.initializeRules();
  }

  initializeRules() {
    return [
      // Ransomware Indicators
      {
        name: 'ransomware_extension_check',
        category: 'ransomware',
        severity: 'CRITICAL',
        description: 'Detects ransomware file extension patterns',
        strings: [
          '.encrypted', '.locked', '.crypto', '.crypt', '.enc',
          '.locky', '.cerber', '.zepto', '.thor', '.zzzzz',
          '.wncry', '.wcry', '.wnry', '.WNCRY'
        ],
        mitre: ['T1486'] // Data Encrypted for Impact
      },
      {
        name: 'ransomware_ransom_note',
        category: 'ransomware',
        severity: 'CRITICAL',
        description: 'Detects ransomware ransom note patterns',
        strings: [
          'Your files have been encrypted',
          'pay bitcoin', 'pay BTC', 'send bitcoin',
          'decrypt your files', 'ransom', 'DECRYPT_INSTRUCTION',
          'README_FOR_DECRYPT', 'HOW_TO_DECRYPT', 'HELP_DECRYPT'
        ],
        mitre: ['T1486', 'T1491']
      },

      // Trojan/RAT Indicators
      {
        name: 'remote_access_trojan',
        category: 'trojan',
        severity: 'HIGH',
        description: 'Detects remote access trojan patterns',
        strings: [
          'keylogger', 'screenshot', 'webcam',
          'GetAsyncKeyState', 'GetForegroundWindow',
          'SetWindowsHookEx', 'CreateRemoteThread',
          'VirtualAllocEx', 'WriteProcessMemory'
        ],
        mitre: ['T1056', 'T1113', 'T1125']
      },
      {
        name: 'process_injection',
        category: 'trojan',
        severity: 'HIGH',
        description: 'Detects process injection techniques',
        strings: [
          'NtCreateThreadEx', 'RtlCreateUserThread',
          'ZwUnmapViewOfSection', 'NtQueueApcThread',
          'SetThreadContext', 'Wow64SetThreadContext'
        ],
        mitre: ['T1055', 'T1055.001', 'T1055.002']
      },

      // Backdoor Indicators
      {
        name: 'reverse_shell',
        category: 'backdoor',
        severity: 'HIGH',
        description: 'Detects reverse shell patterns',
        strings: [
          'cmd.exe /c', 'powershell -e', 'powershell -enc',
          'bash -i', '/bin/sh -i', 'nc -e', 'ncat -e',
          'WSASocketA', 'WSAConnect', 'bind shell'
        ],
        mitre: ['T1059', 'T1059.001', 'T1059.003']
      },
      {
        name: 'persistence_registry',
        category: 'backdoor',
        severity: 'MEDIUM',
        description: 'Detects registry-based persistence',
        strings: [
          'CurrentVersion\\Run', 'CurrentVersion\\RunOnce',
          'Winlogon\\Shell', 'Winlogon\\Userinit',
          'RegSetValueEx', 'RegCreateKeyEx'
        ],
        mitre: ['T1547.001', 'T1112']
      },

      // Rootkit Indicators
      {
        name: 'kernel_manipulation',
        category: 'rootkit',
        severity: 'CRITICAL',
        description: 'Detects kernel-level rootkit patterns',
        strings: [
          'ZwQuerySystemInformation', 'NtQuerySystemInformation',
          'SSDT', 'ServiceDescriptorTable',
          'IoCreateDevice', 'IoCreateSymbolicLink',
          'KeServiceDescriptorTable'
        ],
        mitre: ['T1014', 'T1068']
      },

      // Cryptominer Indicators
      {
        name: 'cryptominer',
        category: 'cryptominer',
        severity: 'MEDIUM',
        description: 'Detects cryptocurrency mining patterns',
        strings: [
          'stratum+tcp', 'mining pool', 'xmrig',
          'coinhive', 'cryptonight', 'monero',
          'bitcoin', 'ethereum', 'wallet address'
        ],
        mitre: ['T1496']
      },

      // Worm Indicators
      {
        name: 'network_spreading',
        category: 'worm',
        severity: 'HIGH',
        description: 'Detects worm spreading patterns',
        strings: [
          'NetShareEnum', 'WNetEnumResource',
          'InternetOpenUrl', 'URLDownloadToFile',
          'SMBv1', 'EternalBlue', 'DoublePulsar'
        ],
        mitre: ['T1021', 'T1570', 'T1210']
      },

      // Dropper/Downloader Indicators
      {
        name: 'payload_dropper',
        category: 'dropper',
        severity: 'HIGH',
        description: 'Detects payload dropper patterns',
        strings: [
          'UrlDownloadToFile', 'URLDownloadToCacheFile',
          'WinExec', 'ShellExecute', 'CreateProcess',
          'PowerShell.exe -NoP', 'mshta.exe', 'certutil -decode'
        ],
        mitre: ['T1105', 'T1204']
      },

      // Spyware Indicators
      {
        name: 'credential_stealer',
        category: 'spyware',
        severity: 'HIGH',
        description: 'Detects credential stealing patterns',
        strings: [
          'passwords.txt', 'credentials.txt',
          'Login Data', 'logins.json', 'key3.db',
          'CredEnumerateA', 'CredEnumerateW',
          'CryptUnprotectData', 'mimikatz'
        ],
        mitre: ['T1555', 'T1555.003', 'T1003']
      },

      // Anti-Analysis Techniques
      {
        name: 'anti_debugging',
        category: 'evasion',
        severity: 'MEDIUM',
        description: 'Detects anti-debugging techniques',
        strings: [
          'IsDebuggerPresent', 'CheckRemoteDebuggerPresent',
          'NtQueryInformationProcess', 'OutputDebugString',
          'GetTickCount', 'QueryPerformanceCounter'
        ],
        mitre: ['T1622', 'T1497']
      },
      {
        name: 'anti_vm',
        category: 'evasion',
        severity: 'MEDIUM',
        description: 'Detects anti-VM techniques',
        strings: [
          'VMware', 'VirtualBox', 'VBOX', 'QEMU',
          'Xen', 'Hyper-V', 'CPUID', 'IN AL, DX',
          'Red Pill', 'No Pill'
        ],
        mitre: ['T1497.001']
      },

      // Packed/Obfuscated
      {
        name: 'packed_executable',
        category: 'packed',
        severity: 'LOW',
        description: 'Detects packed/compressed executables',
        strings: [
          'UPX0', 'UPX1', 'UPX!', 'ASPack',
          'PECompact', 'Themida', 'VMProtect'
        ],
        mitre: ['T1027.002']
      },

      // Command & Control
      {
        name: 'c2_communication',
        category: 'c2',
        severity: 'HIGH',
        description: 'Detects C2 communication patterns',
        strings: [
          'beacon', 'heartbeat', 'checkin',
          'User-Agent: Mozilla', 'POST /gate',
          '/admin/config', '/panel/', '/c2/'
        ],
        mitre: ['T1071', 'T1573', 'T1095']
      },

      // Data Exfiltration
      {
        name: 'data_exfiltration',
        category: 'exfiltration',
        severity: 'HIGH',
        description: 'Detects data exfiltration patterns',
        strings: [
          'FTP upload', 'SMTP send', 'HTTP POST',
          'pastebin.com', 'transfer.sh', 'file.io',
          'rar a -p', '7z a -p', 'base64 encode'
        ],
        mitre: ['T1048', 'T1567', 'T1020']
      }
    ];
  }

  /**
   * Scan buffer/string data against all rules
   */
  scan(data, options = {}) {
    const results = {
      scannedAt: new Date().toISOString(),
      dataSize: typeof data === 'string' ? data.length : data.byteLength,
      matchedRules: [],
      totalMatches: 0,
      severity: 'CLEAN',
      categories: {},
      mitreTechniques: new Set()
    };

    const textData = typeof data === 'string' 
      ? data 
      : Buffer.from(data).toString('utf-8', 0, Math.min(data.length, 1000000));

    const textLower = textData.toLowerCase();

    for (const rule of this.rules) {
      const matches = [];

      for (const pattern of rule.strings) {
        const patternLower = pattern.toLowerCase();
        let index = textLower.indexOf(patternLower);
        
        while (index !== -1) {
          matches.push({
            pattern: pattern,
            offset: index,
            context: textData.substring(
              Math.max(0, index - 20),
              Math.min(textData.length, index + pattern.length + 20)
            ).replace(/[^\x20-\x7E]/g, '.')
          });
          index = textLower.indexOf(patternLower, index + 1);
        }
      }

      if (matches.length > 0) {
        results.matchedRules.push({
          name: rule.name,
          category: rule.category,
          severity: rule.severity,
          description: rule.description,
          matchCount: matches.length,
          matches: matches.slice(0, 5), // Limit to first 5 matches
          mitre: rule.mitre
        });

        results.totalMatches += matches.length;
        results.categories[rule.category] = (results.categories[rule.category] || 0) + 1;
        rule.mitre?.forEach(t => results.mitreTechniques.add(t));
      }
    }

    // Determine overall severity
    const severities = results.matchedRules.map(r => r.severity);
    if (severities.includes('CRITICAL')) results.severity = 'CRITICAL';
    else if (severities.includes('HIGH')) results.severity = 'HIGH';
    else if (severities.includes('MEDIUM')) results.severity = 'MEDIUM';
    else if (severities.includes('LOW')) results.severity = 'LOW';

    results.mitreTechniques = Array.from(results.mitreTechniques);
    results.verdict = results.matchedRules.length > 0 ? 'SUSPICIOUS' : 'CLEAN';

    return results;
  }

  /**
   * Scan extracted strings from a file
   */
  scanStrings(strings) {
    const combinedData = strings.join('\n');
    return this.scan(combinedData);
  }

  /**
   * Get all available rules
   */
  getRules() {
    return this.rules.map(r => ({
      name: r.name,
      category: r.category,
      severity: r.severity,
      description: r.description,
      patternCount: r.strings.length,
      mitre: r.mitre
    }));
  }

  /**
   * Add custom rule
   */
  addRule(rule) {
    if (!rule.name || !rule.strings || !Array.isArray(rule.strings)) {
      throw new Error('Invalid rule format');
    }
    this.rules.push({
      ...rule,
      category: rule.category || 'custom',
      severity: rule.severity || 'MEDIUM',
      description: rule.description || 'Custom rule'
    });
    return { success: true, totalRules: this.rules.length };
  }

  /**
   * Get rule statistics
   */
  getStats() {
    const stats = {
      totalRules: this.rules.length,
      byCategory: {},
      bySeverity: {},
      totalPatterns: 0
    };

    for (const rule of this.rules) {
      stats.byCategory[rule.category] = (stats.byCategory[rule.category] || 0) + 1;
      stats.bySeverity[rule.severity] = (stats.bySeverity[rule.severity] || 0) + 1;
      stats.totalPatterns += rule.strings.length;
    }

    return stats;
  }
}

module.exports = new YaraService();
