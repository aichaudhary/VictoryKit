const MalwareReport = require('../models/Report.model');
const MalwareSample = require('../models/Sample.model');
const { ApiResponse, ApiError } = require('../../../../../shared');

class ReportController {
  async generateReport(req, res, next) {
    try {
      const { reportType, title, timeRange, format = 'pdf' } = req.body;

      const report = new MalwareReport({
        userId: req.user.id,
        reportId: `REPORT-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        reportType,
        title: title || `${reportType.toUpperCase()} Malware Analysis Report`,
        timeRange,
        format,
        status: 'generating'
      });

      await report.save();

      setImmediate(async () => {
        try {
          const query = { userId: req.user.id };
          if (timeRange) query.uploadedAt = { $gte: new Date(timeRange.start), $lte: new Date(timeRange.end) };

          const samples = await MalwareSample.find(query);

          report.summary = {
            totalSamples: samples.length,
            maliciousSamples: samples.filter(s => s.isMalicious).length,
            cleanSamples: samples.filter(s => !s.isMalicious).length,
            criticalThreats: samples.filter(s => s.severity === 'CRITICAL').length,
            topMalwareFamily: this.getTopMalwareFamily(samples),
            detectionRate: (samples.filter(s => s.isMalicious).length / Math.max(samples.length, 1) * 100).toFixed(2)
          };

          report.metrics = {
            malwareBySeverity: this.groupBy(samples, 'severity'),
            malwareByType: this.groupBy(samples, 'malwareType')
          };

          report.topThreats = samples
            .filter(s => s.isMalicious)
            .sort((a, b) => b.confidence - a.confidence)
            .slice(0, 10)
            .map(s => ({
              sampleId: s.sampleId,
              fileName: s.fileName,
              malwareType: s.malwareType,
              severity: s.severity,
              confidence: s.confidence
            }));

          report.recommendations = this.generateRecommendations(report.summary);
          report.fileUrl = `/reports/${report.reportId}.${format}`;
          report.status = 'completed';

          await report.save();
        } catch (error) {
          report.status = 'failed';
          await report.save();
        }
      });

      res.status(201).json(ApiResponse.created(report, 'Report generation started'));
    } catch (error) {
      next(error);
    }
  }

  async getReportById(req, res, next) {
    try {
      const report = await MalwareReport.findById(req.params.id);
      if (!report) throw ApiError.notFound('Report not found');
      if (report.userId.toString() !== req.user.id && req.user.role !== 'admin') throw ApiError.forbidden('Access denied');
      res.json(ApiResponse.success(report));
    } catch (error) {
      next(error);
    }
  }

  async getAllReports(req, res, next) {
    try {
      const { page = 1, limit = 20 } = req.query;
      const reports = await MalwareReport.find({ userId: req.user.id })
        .sort({ createdAt: -1 })
        .limit(limit * 1)
        .skip((page - 1) * limit);
      const total = await MalwareReport.countDocuments({ userId: req.user.id });
      res.json(ApiResponse.success({ reports, pagination: { total, page: parseInt(page), limit: parseInt(limit), pages: Math.ceil(total / limit) } }));
    } catch (error) {
      next(error);
    }
  }

  async exportReport(req, res, next) {
    try {
      const report = await MalwareReport.findById(req.params.id);
      if (!report) throw ApiError.notFound('Report not found');
      if (report.userId.toString() !== req.user.id && req.user.role !== 'admin') throw ApiError.forbidden('Access denied');
      if (report.status !== 'completed') throw ApiError.badRequest('Report not ready');
      res.json(ApiResponse.success({ reportId: report.reportId, format: report.format, downloadUrl: report.fileUrl }));
    } catch (error) {
      next(error);
    }
  }

  async deleteReport(req, res, next) {
    try {
      const report = await MalwareReport.findById(req.params.id);
      if (!report) throw ApiError.notFound('Report not found');
      if (report.userId.toString() !== req.user.id && req.user.role !== 'admin') throw ApiError.forbidden('Access denied');
      await report.deleteOne();
      res.json(ApiResponse.success(null, 'Report deleted'));
    } catch (error) {
      next(error);
    }
  }

  groupBy(samples, field) {
    const result = {};
    samples.forEach(s => {
      const key = s[field] || 'unknown';
      result[key] = (result[key] || 0) + 1;
    });
    return result;
  }

  getTopMalwareFamily(samples) {
    const counts = {};
    samples.forEach(s => {
      counts[s.malwareType] = (counts[s.malwareType] || 0) + 1;
    });
    return Object.entries(counts).sort((a, b) => b[1] - a[1])[0]?.[0] || 'unknown';
  }

  generateRecommendations(summary) {
    const recs = [];
    if (summary.criticalThreats > 0) recs.push({ priority: 'CRITICAL', title: 'Address Critical Threats', description: `${summary.criticalThreats} critical malware samples detected`, actionItems: ['Isolate affected systems', 'Run full scans', 'Update antivirus'] });
    if (summary.detectionRate > 50) recs.push({ priority: 'HIGH', title: 'High Malware Rate', description: `${summary.detectionRate}% detection rate indicates significant exposure`, actionItems: ['Review security controls', 'Conduct security training', 'Update policies'] });
    recs.push({ priority: 'MEDIUM', title: 'Regular Scanning', description: 'Maintain regular malware scanning schedule', actionItems: ['Schedule automated scans', 'Keep signatures updated', 'Monitor alerts'] });
    return recs;
  }
}

module.exports = new ReportController();
