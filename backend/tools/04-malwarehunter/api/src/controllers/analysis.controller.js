const MalwareAnalysis = require('../models/Analysis.model');
const MalwareSample = require('../models/Sample.model');
const { ApiResponse, ApiError } = require('../../../../shared');
const malwareService = require('../services/malware.service');

class AnalysisController {
  async createAnalysis(req, res, next) {
    try {
      const { analysisType, timeRange } = req.body;

      const analysis = new MalwareAnalysis({
        userId: req.user.id,
        analysisId: `ANALYSIS-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        analysisType,
        timeRange,
        status: 'processing'
      });

      await analysis.save();

      setImmediate(async () => {
        try {
          const query = { userId: req.user.id };
          if (timeRange) query.uploadedAt = { $gte: new Date(timeRange.start), $lte: new Date(timeRange.end) };

          const samples = await MalwareSample.find(query);

          analysis.totalSamples = samples.length;
          analysis.maliciousSamples = samples.filter(s => s.isMalicious).length;
          analysis.cleanSamples = samples.filter(s => !s.isMalicious).length;
          analysis.suspiciousSamples = samples.filter(s => s.confidence > 50 && s.confidence < 80).length;
          analysis.criticalThreats = samples.filter(s => s.severity === 'CRITICAL').length;

          const distribution = {};
          samples.forEach(s => {
            distribution[s.malwareType] = (distribution[s.malwareType] || 0) + 1;
          });
          analysis.malwareDistribution = distribution;

          analysis.topMalwareFamilies = Object.entries(distribution)
            .map(([family, count]) => ({ family, count, severity: 'MEDIUM' }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 10);

          analysis.insights = malwareService.generateInsights(samples);
          analysis.status = 'completed';

          await analysis.save();
        } catch (error) {
          analysis.status = 'failed';
          await analysis.save();
        }
      });

      res.status(201).json(ApiResponse.created(analysis, 'Analysis started'));
    } catch (error) {
      next(error);
    }
  }

  async getAnalysisById(req, res, next) {
    try {
      const analysis = await MalwareAnalysis.findById(req.params.id);
      if (!analysis) throw ApiError.notFound('Analysis not found');
      if (analysis.userId.toString() !== req.user.id && req.user.role !== 'admin') throw ApiError.forbidden('Access denied');
      res.json(ApiResponse.success(analysis));
    } catch (error) {
      next(error);
    }
  }

  async getAllAnalyses(req, res, next) {
    try {
      const { page = 1, limit = 20 } = req.query;
      const analyses = await MalwareAnalysis.find({ userId: req.user.id })
        .sort({ createdAt: -1 })
        .limit(limit * 1)
        .skip((page - 1) * limit);
      const total = await MalwareAnalysis.countDocuments({ userId: req.user.id });
      res.json(ApiResponse.success({ analyses, pagination: { total, page: parseInt(page), limit: parseInt(limit), pages: Math.ceil(total / limit) } }));
    } catch (error) {
      next(error);
    }
  }

  async deleteAnalysis(req, res, next) {
    try {
      const analysis = await MalwareAnalysis.findById(req.params.id);
      if (!analysis) throw ApiError.notFound('Analysis not found');
      if (analysis.userId.toString() !== req.user.id && req.user.role !== 'admin') throw ApiError.forbidden('Access denied');
      await analysis.deleteOne();
      res.json(ApiResponse.success(null, 'Analysis deleted'));
    } catch (error) {
      next(error);
    }
  }
}

module.exports = new AnalysisController();
