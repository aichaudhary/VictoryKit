"""
PenTestAI ML Engine - Exploit Selector Model
Smart exploit selection based on vulnerabilities
"""

import numpy as np
import logging
from typing import Dict, Any, List

logger = logging.getLogger(__name__)


class ExploitSelector:
    """
    AI-powered exploit selection and recommendation.
    """
    
    def __init__(self):
        self.version = "1.0.0"
        self.is_loaded = True
        
        # Exploit database (simplified)
        self.exploit_db = {
            "sql_injection": [
                {"name": "sqlmap", "type": "tool", "success_rate": 0.85, "technique": "T1190"},
                {"name": "union_based", "type": "manual", "success_rate": 0.7, "technique": "T1190"},
                {"name": "blind_sqli", "type": "manual", "success_rate": 0.6, "technique": "T1190"}
            ],
            "xss": [
                {"name": "stored_xss_payload", "type": "payload", "success_rate": 0.75, "technique": "T1059.007"},
                {"name": "dom_xss_payload", "type": "payload", "success_rate": 0.65, "technique": "T1059.007"}
            ],
            "rce": [
                {"name": "metasploit_module", "type": "framework", "success_rate": 0.8, "technique": "T1203"},
                {"name": "reverse_shell", "type": "payload", "success_rate": 0.7, "technique": "T1059"}
            ],
            "authentication_bypass": [
                {"name": "credential_spray", "type": "tool", "success_rate": 0.5, "technique": "T1110.003"},
                {"name": "default_creds", "type": "manual", "success_rate": 0.4, "technique": "T1078.001"}
            ],
            "ssrf": [
                {"name": "ssrf_scanner", "type": "tool", "success_rate": 0.7, "technique": "T1190"},
                {"name": "cloud_metadata", "type": "payload", "success_rate": 0.6, "technique": "T1552.005"}
            ],
            "file_upload": [
                {"name": "webshell_upload", "type": "payload", "success_rate": 0.65, "technique": "T1505.003"},
                {"name": "polyglot_file", "type": "payload", "success_rate": 0.55, "technique": "T1505.003"}
            ]
        }
        
        # Category mapping
        self.category_mapping = {
            "injection": "sql_injection",
            "xss": "xss",
            "cross-site scripting": "xss",
            "remote code execution": "rce",
            "rce": "rce",
            "command injection": "rce",
            "authentication": "authentication_bypass",
            "auth bypass": "authentication_bypass",
            "ssrf": "ssrf",
            "server-side request forgery": "ssrf",
            "file upload": "file_upload",
            "unrestricted upload": "file_upload"
        }
        
        logger.info(f"Exploit Selector v{self.version} loaded")
    
    def select(self, vuln: Dict[str, Any], target: Dict[str, Any]) -> Dict[str, Any]:
        """Select best exploits for vulnerability"""
        
        category = vuln.get("category", "").lower()
        severity = vuln.get("severity", "MEDIUM")
        target_type = target.get("target_type", "web_app")
        
        # Map category to exploit type
        exploit_type = self._map_category(category)
        
        # Get available exploits
        exploits = self._get_exploits(exploit_type, target_type)
        
        # Calculate success probability
        success_prob = self._calculate_success_probability(exploits, severity)
        
        # Get prerequisites
        prerequisites = self._get_prerequisites(exploit_type, target_type)
        
        # Get MITRE techniques
        techniques = list(set(e.get("technique", "") for e in exploits if e.get("technique")))
        
        return {
            "exploits": exploits,
            "success_probability": success_prob,
            "prerequisites": prerequisites,
            "mitre_techniques": techniques
        }
    
    def _map_category(self, category: str) -> str:
        """Map vulnerability category to exploit type"""
        
        for key, value in self.category_mapping.items():
            if key in category:
                return value
        return "rce"  # Default to RCE
    
    def _get_exploits(self, exploit_type: str, target_type: str) -> List[Dict[str, Any]]:
        """Get exploits for type"""
        
        exploits = self.exploit_db.get(exploit_type, [])
        
        # Sort by success rate
        sorted_exploits = sorted(exploits, key=lambda x: x.get("success_rate", 0), reverse=True)
        
        # Add recommendations
        for i, exploit in enumerate(sorted_exploits):
            exploit["recommended"] = i < 2
            exploit["rank"] = i + 1
        
        return sorted_exploits[:5]
    
    def _calculate_success_probability(self, exploits: List[Dict[str, Any]], severity: str) -> float:
        """Calculate overall success probability"""
        
        if not exploits:
            return 0.2
        
        # Base probability from top exploit
        base_prob = exploits[0].get("success_rate", 0.5)
        
        # Adjust based on severity
        severity_modifier = {
            "CRITICAL": 1.2,
            "HIGH": 1.1,
            "MEDIUM": 1.0,
            "LOW": 0.8
        }
        
        modifier = severity_modifier.get(severity, 1.0)
        probability = min(base_prob * modifier * 100, 95)
        
        return round(probability, 1)
    
    def _get_prerequisites(self, exploit_type: str, target_type: str) -> List[str]:
        """Get exploit prerequisites"""
        
        prereqs = {
            "sql_injection": [
                "Valid input parameter identified",
                "Database type detected",
                "Error-based or blind injection confirmed"
            ],
            "xss": [
                "Reflected input identified",
                "No CSP or bypassable CSP",
                "User interaction possible"
            ],
            "rce": [
                "Vulnerable component confirmed",
                "Network access to target",
                "Payload delivery mechanism available"
            ],
            "authentication_bypass": [
                "Valid username enumerated",
                "No account lockout or rate limiting",
                "Authentication mechanism identified"
            ],
            "ssrf": [
                "URL parameter identified",
                "Internal network access needed",
                "Protocol handlers available"
            ],
            "file_upload": [
                "Upload functionality accessible",
                "File type validation bypassable",
                "Upload directory accessible"
            ]
        }
        
        return prereqs.get(exploit_type, ["Vulnerability confirmed", "Target accessible"])
