"""
PenTestAI ML Engine - Attack Planner Model
AI-driven attack path generation
"""

import numpy as np
import logging
from typing import Dict, Any, List

logger = logging.getLogger(__name__)


class AttackPlanner:
    """
    AI-powered attack planning and path generation.
    """
    
    def __init__(self):
        self.version = "1.0.0"
        self.is_loaded = True
        
        # MITRE ATT&CK techniques mapping
        self.attack_techniques = {
            "reconnaissance": ["T1595", "T1592", "T1589", "T1590"],
            "initial_access": ["T1190", "T1133", "T1566", "T1078"],
            "execution": ["T1059", "T1203", "T1047"],
            "persistence": ["T1098", "T1136", "T1053"],
            "privilege_escalation": ["T1068", "T1055", "T1548"],
            "credential_access": ["T1110", "T1003", "T1552"],
            "lateral_movement": ["T1021", "T1534", "T1570"],
            "exfiltration": ["T1041", "T1048", "T1567"]
        }
        
        # Target type attack patterns
        self.target_patterns = {
            "web_app": ["reconnaissance", "initial_access", "execution", "privilege_escalation"],
            "network": ["reconnaissance", "initial_access", "lateral_movement", "exfiltration"],
            "api": ["reconnaissance", "initial_access", "credential_access"],
            "cloud": ["reconnaissance", "initial_access", "privilege_escalation", "exfiltration"],
            "iot": ["reconnaissance", "initial_access", "persistence", "lateral_movement"]
        }
        
        logger.info(f"Attack Planner v{self.version} loaded")
    
    def generate_plan(self, target: Dict[str, Any]) -> Dict[str, Any]:
        """Generate comprehensive attack plan"""
        
        target_type = target.get("target_type", "web_app")
        host = target.get("host", "")
        tech_stack = target.get("technology_stack", [])
        services = target.get("services", [])
        
        # Get attack phases based on target type
        phases = self._generate_phases(target_type, tech_stack)
        
        # Generate attack paths
        attack_paths = self._generate_attack_paths(target_type, tech_stack, services)
        
        # Identify priority targets
        priority_targets = self._identify_priority_targets(host, services, tech_stack)
        
        # Get relevant MITRE techniques
        techniques = self._get_techniques(target_type)
        
        # Estimate duration
        duration = self._estimate_duration(target_type, len(phases))
        
        return {
            "phases": phases,
            "attack_paths": attack_paths,
            "estimated_duration": duration,
            "techniques": techniques,
            "priority_targets": priority_targets
        }
    
    def analyze_target(self, target: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze target for attack surface"""
        
        target_type = target.get("target_type", "web_app")
        tech_stack = target.get("technology_stack", [])
        services = target.get("services", [])
        
        # Analyze attack surface
        attack_surface = self._analyze_attack_surface(target_type, tech_stack, services)
        
        # Identify potential vulnerabilities
        potential_vulns = self._identify_potential_vulns(tech_stack)
        
        # Risk assessment
        risk_level = self._assess_risk(len(services), len(potential_vulns))
        
        return {
            "attack_surface": attack_surface,
            "potential_vulnerabilities": potential_vulns,
            "risk_level": risk_level,
            "recommended_techniques": self._get_techniques(target_type)[:5],
            "complexity": self._assess_complexity(target_type, tech_stack)
        }
    
    def _generate_phases(self, target_type: str, tech_stack: List[str]) -> List[Dict[str, Any]]:
        """Generate attack phases"""
        
        base_phases = [
            {
                "name": "Reconnaissance",
                "order": 1,
                "description": "Gather information about target",
                "duration_estimate": "2-4 hours",
                "techniques": self.attack_techniques["reconnaissance"][:2],
                "tools": ["nmap", "whatweb", "amass"]
            },
            {
                "name": "Vulnerability Assessment",
                "order": 2,
                "description": "Identify vulnerabilities",
                "duration_estimate": "4-8 hours",
                "techniques": ["T1595.002", "T1592.002"],
                "tools": ["nuclei", "nikto", "sqlmap"]
            },
            {
                "name": "Exploitation",
                "order": 3,
                "description": "Exploit identified vulnerabilities",
                "duration_estimate": "4-12 hours",
                "techniques": self.attack_techniques["initial_access"][:2],
                "tools": ["metasploit", "burpsuite"]
            },
            {
                "name": "Post-Exploitation",
                "order": 4,
                "description": "Escalate privileges and maintain access",
                "duration_estimate": "4-8 hours",
                "techniques": self.attack_techniques["privilege_escalation"][:2],
                "tools": ["mimikatz", "linpeas"]
            },
            {
                "name": "Reporting",
                "order": 5,
                "description": "Document findings and remediation",
                "duration_estimate": "4-8 hours",
                "techniques": [],
                "tools": ["custom_reporter"]
            }
        ]
        
        return base_phases
    
    def _generate_attack_paths(
        self, 
        target_type: str, 
        tech_stack: List[str], 
        services: List[str]
    ) -> List[Dict[str, Any]]:
        """Generate possible attack paths"""
        
        paths = []
        
        # Path 1: Web Application Attack
        if target_type == "web_app" or any(s in services for s in ["http", "https"]):
            paths.append({
                "name": "Web Application Exploitation",
                "probability": 0.7,
                "steps": [
                    "Enumerate web endpoints",
                    "Identify injection points",
                    "Exploit SQL/XSS/RCE vulnerabilities",
                    "Escalate to admin access"
                ],
                "risk_level": "HIGH"
            })
        
        # Path 2: Authentication Attack
        if any(s in services for s in ["ssh", "rdp", "ftp"]):
            paths.append({
                "name": "Credential Attack",
                "probability": 0.5,
                "steps": [
                    "Enumerate valid users",
                    "Attempt password spray",
                    "Exploit weak credentials",
                    "Pivot to internal network"
                ],
                "risk_level": "MEDIUM"
            })
        
        # Path 3: API Attack
        if target_type == "api":
            paths.append({
                "name": "API Security Bypass",
                "probability": 0.6,
                "steps": [
                    "Map API endpoints",
                    "Test authentication bypass",
                    "Exploit IDOR vulnerabilities",
                    "Extract sensitive data"
                ],
                "risk_level": "HIGH"
            })
        
        return paths if paths else [{
            "name": "Generic Attack Path",
            "probability": 0.4,
            "steps": ["Reconnaissance", "Vulnerability scan", "Exploitation attempt"],
            "risk_level": "MEDIUM"
        }]
    
    def _identify_priority_targets(
        self, 
        host: str, 
        services: List[str], 
        tech_stack: List[str]
    ) -> List[Dict[str, Any]]:
        """Identify high-priority attack targets"""
        
        priorities = []
        
        # High value services
        high_value = {
            "mysql": "Database access",
            "postgresql": "Database access",
            "mongodb": "Database access",
            "redis": "Cache/session data",
            "ssh": "Remote shell access",
            "rdp": "Desktop access",
            "smb": "File share access"
        }
        
        for service in services:
            if service.lower() in high_value:
                priorities.append({
                    "service": service,
                    "value": high_value[service.lower()],
                    "priority": "HIGH"
                })
        
        # Known vulnerable technologies
        vulnerable_tech = ["struts", "log4j", "spring", "wordpress", "drupal"]
        for tech in tech_stack:
            if any(v in tech.lower() for v in vulnerable_tech):
                priorities.append({
                    "technology": tech,
                    "value": "Known vulnerable framework",
                    "priority": "CRITICAL"
                })
        
        return priorities
    
    def _get_techniques(self, target_type: str) -> List[str]:
        """Get relevant MITRE ATT&CK techniques"""
        
        pattern = self.target_patterns.get(target_type, ["reconnaissance", "initial_access"])
        techniques = []
        for phase in pattern:
            techniques.extend(self.attack_techniques.get(phase, []))
        return techniques
    
    def _estimate_duration(self, target_type: str, num_phases: int) -> str:
        """Estimate test duration"""
        
        base_hours = num_phases * 4
        if target_type in ["network", "cloud"]:
            base_hours *= 1.5
        
        return f"{int(base_hours)}-{int(base_hours * 1.5)} hours"
    
    def _analyze_attack_surface(
        self, 
        target_type: str, 
        tech_stack: List[str], 
        services: List[str]
    ) -> Dict[str, Any]:
        """Analyze attack surface"""
        
        return {
            "external_endpoints": len(services),
            "technology_components": len(tech_stack),
            "surface_size": "LARGE" if len(services) > 5 else "MEDIUM" if len(services) > 2 else "SMALL",
            "complexity": "HIGH" if len(tech_stack) > 3 else "MEDIUM"
        }
    
    def _identify_potential_vulns(self, tech_stack: List[str]) -> List[Dict[str, str]]:
        """Identify potential vulnerabilities based on tech stack"""
        
        vulns = []
        vuln_mapping = {
            "wordpress": {"type": "CMS Vulnerabilities", "severity": "HIGH"},
            "drupal": {"type": "CMS Vulnerabilities", "severity": "HIGH"},
            "apache": {"type": "Web Server Misconfiguration", "severity": "MEDIUM"},
            "nginx": {"type": "Web Server Misconfiguration", "severity": "MEDIUM"},
            "php": {"type": "Code Injection", "severity": "HIGH"},
            "java": {"type": "Deserialization", "severity": "CRITICAL"},
            "node": {"type": "Prototype Pollution", "severity": "MEDIUM"}
        }
        
        for tech in tech_stack:
            for key, vuln in vuln_mapping.items():
                if key in tech.lower():
                    vulns.append({
                        "technology": tech,
                        **vuln
                    })
        
        return vulns
    
    def _assess_risk(self, service_count: int, vuln_count: int) -> str:
        """Assess overall risk level"""
        
        score = service_count * 2 + vuln_count * 3
        if score >= 15:
            return "CRITICAL"
        elif score >= 10:
            return "HIGH"
        elif score >= 5:
            return "MEDIUM"
        return "LOW"
    
    def _assess_complexity(self, target_type: str, tech_stack: List[str]) -> str:
        """Assess attack complexity"""
        
        if len(tech_stack) > 5 or target_type in ["cloud", "network"]:
            return "HIGH"
        elif len(tech_stack) > 2:
            return "MEDIUM"
        return "LOW"
