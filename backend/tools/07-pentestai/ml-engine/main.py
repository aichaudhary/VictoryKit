"""
PenTestAI ML Engine - Main FastAPI Application
AI-Assisted Penetration Testing
"""

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
from typing import List, Optional, Dict, Any
from datetime import datetime
import logging

from models.attack_planner import AttackPlanner
from models.exploit_selector import ExploitSelector
from models.report_generator import ReportGenerator

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI(
    title="PenTestAI ML Engine",
    description="AI-Assisted Penetration Testing Engine",
    version="1.0.0",
)

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize models
attack_planner = AttackPlanner()
exploit_selector = ExploitSelector()
report_generator = ReportGenerator()


# Pydantic models
class TargetInput(BaseModel):
    target_id: str
    target_type: str  # 'web_app', 'network', 'api', 'mobile', 'cloud', 'iot'
    host: str
    port: Optional[int] = None
    technology_stack: Optional[List[str]] = []
    services: Optional[List[str]] = []


class VulnerabilityInput(BaseModel):
    vuln_id: str
    title: str
    severity: str
    category: str
    affected_component: str
    cvss_score: Optional[float] = None


class AttackPlan(BaseModel):
    target_id: str
    phases: List[Dict[str, Any]]
    attack_paths: List[Dict[str, Any]]
    estimated_duration: str
    techniques: List[str]
    priority_targets: List[Dict[str, Any]]


class ExploitRecommendation(BaseModel):
    vuln_id: str
    recommended_exploits: List[Dict[str, Any]]
    success_probability: float
    prerequisites: List[str]
    mitre_techniques: List[str]


class PentestReport(BaseModel):
    test_id: str
    executive_summary: str
    findings_summary: Dict[str, Any]
    detailed_findings: List[Dict[str, Any]]
    recommendations: List[Dict[str, Any]]
    risk_rating: str


# Health check
@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "service": "PenTestAI ML Engine",
        "version": "1.0.0",
        "models_loaded": {
            "attack_planner": attack_planner.is_loaded,
            "exploit_selector": exploit_selector.is_loaded,
            "report_generator": report_generator.is_loaded,
        }
    }


# Generate attack plan
@app.post("/plan/attack", response_model=AttackPlan)
async def plan_attack(target: TargetInput):
    try:
        logger.info(f"Generating attack plan for target {target.target_id}")
        
        plan = attack_planner.generate_plan(target.model_dump())
        
        return AttackPlan(
            target_id=target.target_id,
            phases=plan["phases"],
            attack_paths=plan["attack_paths"],
            estimated_duration=plan["estimated_duration"],
            techniques=plan["techniques"],
            priority_targets=plan["priority_targets"]
        )
    except Exception as e:
        logger.error(f"Error generating attack plan: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# Select exploits
@app.post("/select/exploits", response_model=ExploitRecommendation)
async def select_exploits(vuln: VulnerabilityInput, target: TargetInput):
    try:
        logger.info(f"Selecting exploits for {vuln.vuln_id}")
        
        result = exploit_selector.select(vuln.model_dump(), target.model_dump())
        
        return ExploitRecommendation(
            vuln_id=vuln.vuln_id,
            recommended_exploits=result["exploits"],
            success_probability=result["success_probability"],
            prerequisites=result["prerequisites"],
            mitre_techniques=result["mitre_techniques"]
        )
    except Exception as e:
        logger.error(f"Error selecting exploits: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# Analyze target
@app.post("/analyze/target")
async def analyze_target(target: TargetInput):
    try:
        logger.info(f"Analyzing target {target.target_id}")
        
        analysis = attack_planner.analyze_target(target.model_dump())
        return analysis
    except Exception as e:
        logger.error(f"Error analyzing target: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# Generate report
@app.post("/generate/report", response_model=PentestReport)
async def generate_report(
    test_id: str,
    findings: List[Dict[str, Any]],
    target: TargetInput
):
    try:
        logger.info(f"Generating report for test {test_id}")
        
        report = report_generator.generate(test_id, findings, target.model_dump())
        
        return PentestReport(
            test_id=test_id,
            executive_summary=report["executive_summary"],
            findings_summary=report["findings_summary"],
            detailed_findings=report["detailed_findings"],
            recommendations=report["recommendations"],
            risk_rating=report["risk_rating"]
        )
    except Exception as e:
        logger.error(f"Error generating report: {e}")
        raise HTTPException(status_code=500, detail=str(e))


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8007)
