/**
 * Reconnaissance Service - Information gathering and OSINT
 * Handles passive and active reconnaissance operations
 */

const axios = require('axios');
const dns = require('dns').promises;
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);
const logger = require('../../../../../shared/utils/logger');

class ReconService {
  constructor() {
    this.shodanKey = process.env.SHODAN_API_KEY;
    this.nmapPath = process.env.PENTESTAI_NMAP_PATH || 'nmap';
  }

  /**
   * Perform comprehensive reconnaissance on a target
   */
  async fullRecon(target, options = {}) {
    const results = {
      target,
      timestamp: new Date(),
      passive: {},
      active: {},
      summary: {}
    };

    const tasks = [];

    // Passive Recon (safe, no direct contact with target)
    if (options.passive !== false) {
      tasks.push(
        this.dnsEnumeration(target).then(r => { results.passive.dns = r; }),
        this.whoisLookup(target).then(r => { results.passive.whois = r; }),
        this.subdomainEnum(target).then(r => { results.passive.subdomains = r; })
      );

      if (this.shodanKey) {
        tasks.push(
          this.shodanLookup(target).then(r => { results.passive.shodan = r; })
        );
      }
    }

    // Active Recon (directly contacts target)
    if (options.active !== false) {
      tasks.push(
        this.portScan(target, options.ports).then(r => { results.active.ports = r; }),
        this.serviceDetection(target, options.ports).then(r => { results.active.services = r; })
      );

      if (options.osDetection) {
        tasks.push(
          this.osFingerprint(target).then(r => { results.active.os = r; })
        );
      }

      if (options.webRecon && this.isWebTarget(target)) {
        tasks.push(
          this.webRecon(target).then(r => { results.active.web = r; })
        );
      }
    }

    await Promise.allSettled(tasks);

    // Generate summary
    results.summary = this.generateSummary(results);

    return results;
  }

  /**
   * DNS Enumeration
   */
  async dnsEnumeration(target) {
    const results = {
      records: {},
      nameservers: [],
      mailServers: []
    };

    try {
      // Get domain from target
      const domain = this.extractDomain(target);

      // A Records
      try {
        results.records.A = await dns.resolve4(domain);
      } catch (e) { results.records.A = []; }

      // AAAA Records (IPv6)
      try {
        results.records.AAAA = await dns.resolve6(domain);
      } catch (e) { results.records.AAAA = []; }

      // MX Records
      try {
        const mx = await dns.resolveMx(domain);
        results.records.MX = mx;
        results.mailServers = mx.map(m => m.exchange);
      } catch (e) { results.records.MX = []; }

      // NS Records
      try {
        const ns = await dns.resolveNs(domain);
        results.records.NS = ns;
        results.nameservers = ns;
      } catch (e) { results.records.NS = []; }

      // TXT Records
      try {
        results.records.TXT = await dns.resolveTxt(domain);
      } catch (e) { results.records.TXT = []; }

      // CNAME
      try {
        results.records.CNAME = await dns.resolveCname(domain);
      } catch (e) { results.records.CNAME = []; }

      // SOA
      try {
        results.records.SOA = await dns.resolveSoa(domain);
      } catch (e) { results.records.SOA = null; }

    } catch (error) {
      logger.error('DNS enumeration error:', error);
      results.error = error.message;
    }

    return results;
  }

  /**
   * WHOIS Lookup
   */
  async whoisLookup(target) {
    try {
      const domain = this.extractDomain(target);
      const { stdout } = await execPromise(`whois ${domain} 2>/dev/null || echo "WHOIS not available"`);
      
      // Parse WHOIS output
      const info = {
        raw: stdout,
        registrar: this.extractWhoisField(stdout, 'Registrar'),
        creationDate: this.extractWhoisField(stdout, 'Creation Date'),
        expirationDate: this.extractWhoisField(stdout, 'Expiration Date'),
        nameServers: this.extractWhoisFields(stdout, 'Name Server'),
        registrant: this.extractWhoisField(stdout, 'Registrant'),
        organization: this.extractWhoisField(stdout, 'Organization')
      };

      return info;
    } catch (error) {
      return { error: error.message };
    }
  }

  /**
   * Subdomain Enumeration
   */
  async subdomainEnum(target) {
    const domain = this.extractDomain(target);
    const subdomains = new Set();

    // Common subdomain prefixes to check
    const commonPrefixes = [
      'www', 'mail', 'ftp', 'webmail', 'smtp', 'pop', 'ns1', 'ns2',
      'admin', 'portal', 'api', 'dev', 'staging', 'test', 'vpn',
      'remote', 'cdn', 'static', 'assets', 'img', 'images', 'css',
      'js', 'app', 'mobile', 'beta', 'alpha', 'shop', 'store',
      'blog', 'forum', 'wiki', 'docs', 'help', 'support', 'status',
      'git', 'gitlab', 'github', 'jenkins', 'ci', 'cd', 'docker',
      'kubernetes', 'k8s', 'cloud', 'aws', 'azure', 'gcp', 'db',
      'database', 'mysql', 'postgres', 'redis', 'elastic', 'kibana',
      'grafana', 'prometheus', 'monitor', 'logs', 'auth', 'sso',
      'oauth', 'login', 'secure', 'ssl', 'internal', 'intranet'
    ];

    // Check each prefix
    const checkPromises = commonPrefixes.map(async prefix => {
      const subdomain = `${prefix}.${domain}`;
      try {
        await dns.resolve4(subdomain);
        subdomains.add(subdomain);
      } catch (e) {
        // Subdomain doesn't exist
      }
    });

    await Promise.allSettled(checkPromises);

    // Try certificate transparency logs
    try {
      const ctSubdomains = await this.getCTSubdomains(domain);
      ctSubdomains.forEach(s => subdomains.add(s));
    } catch (e) {
      logger.warn('CT log lookup failed:', e.message);
    }

    return Array.from(subdomains);
  }

  /**
   * Get subdomains from Certificate Transparency logs
   */
  async getCTSubdomains(domain) {
    try {
      const response = await axios.get(
        `https://crt.sh/?q=%.${domain}&output=json`,
        { timeout: 10000 }
      );

      const subdomains = new Set();
      response.data.forEach(cert => {
        const name = cert.name_value;
        if (name) {
          name.split('\n').forEach(n => {
            if (n.endsWith(domain) && !n.includes('*')) {
              subdomains.add(n.toLowerCase());
            }
          });
        }
      });

      return Array.from(subdomains);
    } catch (error) {
      return [];
    }
  }

  /**
   * Shodan Lookup
   */
  async shodanLookup(target) {
    if (!this.shodanKey) {
      return { error: 'Shodan API key not configured' };
    }

    try {
      const ip = await this.resolveToIP(target);
      
      const response = await axios.get(
        `https://api.shodan.io/shodan/host/${ip}`,
        { params: { key: this.shodanKey } }
      );

      return {
        ip: response.data.ip_str,
        hostnames: response.data.hostnames || [],
        org: response.data.org,
        asn: response.data.asn,
        isp: response.data.isp,
        country: response.data.country_name,
        city: response.data.city,
        ports: response.data.ports || [],
        vulns: response.data.vulns || [],
        services: (response.data.data || []).map(s => ({
          port: s.port,
          transport: s.transport,
          product: s.product,
          version: s.version,
          banner: s.data?.substring(0, 500)
        }))
      };
    } catch (error) {
      if (error.response?.status === 404) {
        return { message: 'Host not found in Shodan database' };
      }
      return { error: error.message };
    }
  }

  /**
   * Port Scanning
   */
  async portScan(target, ports = '1-1000') {
    try {
      const { stdout } = await execPromise(
        `${this.nmapPath} -Pn -p ${ports} --open -oG - ${target} 2>/dev/null`,
        { timeout: 120000 }
      );

      const openPorts = [];
      const portMatch = stdout.match(/Ports: ([^\t]+)/);
      
      if (portMatch) {
        const portList = portMatch[1].split(', ');
        portList.forEach(p => {
          const parts = p.split('/');
          if (parts[1] === 'open') {
            openPorts.push({
              port: parseInt(parts[0]),
              state: parts[1],
              protocol: parts[2],
              service: parts[4] || 'unknown'
            });
          }
        });
      }

      return {
        target,
        portsScanned: ports,
        openPorts
      };
    } catch (error) {
      // Fallback to native port scan
      return this.nativePortScan(target, ports);
    }
  }

  /**
   * Native port scan fallback
   */
  async nativePortScan(target, portRange) {
    const net = require('net');
    const openPorts = [];
    const ports = this.parsePortRange(portRange);
    const ip = await this.resolveToIP(target);

    const scanPort = (port) => {
      return new Promise(resolve => {
        const socket = new net.Socket();
        socket.setTimeout(1000);

        socket.on('connect', () => {
          openPorts.push({ port, state: 'open', protocol: 'tcp' });
          socket.destroy();
          resolve();
        });

        socket.on('timeout', () => {
          socket.destroy();
          resolve();
        });

        socket.on('error', () => {
          resolve();
        });

        socket.connect(port, ip);
      });
    };

    // Scan in batches
    const batchSize = 100;
    for (let i = 0; i < ports.length; i += batchSize) {
      const batch = ports.slice(i, i + batchSize);
      await Promise.all(batch.map(scanPort));
    }

    return { target, portsScanned: portRange, openPorts };
  }

  /**
   * Service Detection
   */
  async serviceDetection(target, ports = '1-1000') {
    try {
      const { stdout } = await execPromise(
        `${this.nmapPath} -Pn -sV -p ${ports} --version-intensity 5 ${target} 2>/dev/null`,
        { timeout: 300000 }
      );

      const services = [];
      const lines = stdout.split('\n');
      
      lines.forEach(line => {
        const match = line.match(/^(\d+)\/(tcp|udp)\s+open\s+(\S+)\s*(.*)/);
        if (match) {
          services.push({
            port: parseInt(match[1]),
            protocol: match[2],
            service: match[3],
            version: match[4].trim()
          });
        }
      });

      return { target, services };
    } catch (error) {
      return { error: error.message, target };
    }
  }

  /**
   * OS Fingerprinting
   */
  async osFingerprint(target) {
    try {
      const { stdout } = await execPromise(
        `sudo ${this.nmapPath} -Pn -O --osscan-guess ${target} 2>/dev/null`,
        { timeout: 120000 }
      );

      const osMatch = stdout.match(/OS details: ([^\n]+)/);
      const accuracyMatch = stdout.match(/Aggressive OS guesses: ([^\n]+)/);

      return {
        target,
        os: osMatch ? osMatch[1] : 'Unknown',
        guesses: accuracyMatch ? accuracyMatch[1].split(', ').map(g => {
          const parts = g.match(/(.+) \((\d+)%\)/);
          return parts ? { os: parts[1], confidence: parseInt(parts[2]) } : null;
        }).filter(Boolean) : []
      };
    } catch (error) {
      return { error: error.message, target };
    }
  }

  /**
   * Web Application Reconnaissance
   */
  async webRecon(target) {
    const url = target.startsWith('http') ? target : `https://${target}`;
    const results = {
      url,
      technologies: [],
      headers: {},
      robots: null,
      sitemap: null
    };

    try {
      // Get headers and detect technologies
      const response = await axios.get(url, {
        timeout: 10000,
        validateStatus: () => true,
        maxRedirects: 5
      });

      results.statusCode = response.status;
      results.headers = response.headers;
      results.technologies = this.detectTechnologies(response);

      // Get robots.txt
      try {
        const robotsRes = await axios.get(`${url}/robots.txt`, { timeout: 5000 });
        results.robots = robotsRes.data;
      } catch (e) {}

      // Get sitemap.xml
      try {
        const sitemapRes = await axios.get(`${url}/sitemap.xml`, { timeout: 5000 });
        results.sitemap = sitemapRes.data?.substring(0, 10000);
      } catch (e) {}

    } catch (error) {
      results.error = error.message;
    }

    return results;
  }

  /**
   * Detect web technologies from response
   */
  detectTechnologies(response) {
    const techs = [];
    const headers = response.headers;
    const body = response.data?.toLowerCase() || '';

    // Server
    if (headers.server) {
      techs.push({ category: 'Server', name: headers.server });
    }

    // Powered by
    if (headers['x-powered-by']) {
      techs.push({ category: 'Framework', name: headers['x-powered-by'] });
    }

    // Common frameworks detection
    const frameworks = [
      { pattern: 'wp-content', name: 'WordPress', category: 'CMS' },
      { pattern: 'drupal', name: 'Drupal', category: 'CMS' },
      { pattern: 'joomla', name: 'Joomla', category: 'CMS' },
      { pattern: 'react', name: 'React', category: 'JavaScript Framework' },
      { pattern: 'angular', name: 'Angular', category: 'JavaScript Framework' },
      { pattern: 'vue', name: 'Vue.js', category: 'JavaScript Framework' },
      { pattern: 'jquery', name: 'jQuery', category: 'JavaScript Library' },
      { pattern: 'bootstrap', name: 'Bootstrap', category: 'CSS Framework' },
      { pattern: 'laravel', name: 'Laravel', category: 'PHP Framework' },
      { pattern: 'django', name: 'Django', category: 'Python Framework' },
      { pattern: 'rails', name: 'Ruby on Rails', category: 'Ruby Framework' },
      { pattern: 'asp.net', name: 'ASP.NET', category: '.NET Framework' }
    ];

    frameworks.forEach(fw => {
      if (body.includes(fw.pattern)) {
        techs.push({ category: fw.category, name: fw.name });
      }
    });

    return techs;
  }

  // Helper methods
  extractDomain(target) {
    try {
      if (target.includes('://')) {
        return new URL(target).hostname;
      }
      return target.replace(/^www\./, '').split('/')[0];
    } catch {
      return target;
    }
  }

  async resolveToIP(target) {
    const domain = this.extractDomain(target);
    try {
      const addresses = await dns.resolve4(domain);
      return addresses[0];
    } catch {
      return domain;
    }
  }

  isWebTarget(target) {
    return target.includes('://') || target.includes('www.');
  }

  extractWhoisField(text, field) {
    const regex = new RegExp(`${field}:\\s*(.+)`, 'i');
    const match = text.match(regex);
    return match ? match[1].trim() : null;
  }

  extractWhoisFields(text, field) {
    const regex = new RegExp(`${field}:\\s*(.+)`, 'gi');
    const matches = [];
    let match;
    while ((match = regex.exec(text)) !== null) {
      matches.push(match[1].trim());
    }
    return matches;
  }

  parsePortRange(range) {
    const ports = [];
    range.split(',').forEach(part => {
      if (part.includes('-')) {
        const [start, end] = part.split('-').map(Number);
        for (let i = start; i <= Math.min(end, start + 1000); i++) {
          ports.push(i);
        }
      } else {
        ports.push(parseInt(part));
      }
    });
    return [...new Set(ports)].slice(0, 1000);
  }

  generateSummary(results) {
    return {
      totalOpenPorts: results.active.ports?.openPorts?.length || 0,
      totalServices: results.active.services?.services?.length || 0,
      subdomainsFound: results.passive.subdomains?.length || 0,
      os: results.active.os?.os || 'Unknown',
      technologies: results.active.web?.technologies?.length || 0,
      hasVulnerabilities: (results.passive.shodan?.vulns?.length || 0) > 0
    };
  }
}

module.exports = new ReconService();
