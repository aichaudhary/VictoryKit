const axios = require('axios');
const { config } = require('../../../../../shared');

class MLService {
  constructor() {
    this.baseUrl = process.env.ML_PENTESTAI_URL || 'http://localhost:8007';
    this.timeout = 120000;
  }

  async analyzeTarget(targetData) {
    try {
      const response = await axios.post(`${this.baseUrl}/analyze/target`, targetData, {
        timeout: this.timeout
      });
      return response.data;
    } catch (error) {
      console.error('ML target analysis error:', error.message);
      return this.fallbackTargetAnalysis(targetData);
    }
  }

  async generateAttackPlan(target, testType) {
    try {
      const response = await axios.post(`${this.baseUrl}/generate/attack-plan`, {
        target,
        testType
      }, { timeout: this.timeout });
      return response.data;
    } catch (error) {
      console.error('ML attack plan error:', error.message);
      return this.fallbackAttackPlan(target, testType);
    }
  }

  async analyzeVulnerability(finding) {
    try {
      const response = await axios.post(`${this.baseUrl}/analyze/vulnerability`, finding, {
        timeout: this.timeout
      });
      return response.data;
    } catch (error) {
      console.error('ML vulnerability analysis error:', error.message);
      return this.fallbackVulnAnalysis(finding);
    }
  }

  async generateExploit(vulnerability) {
    try {
      const response = await axios.post(`${this.baseUrl}/generate/exploit`, vulnerability, {
        timeout: this.timeout
      });
      return response.data;
    } catch (error) {
      console.error('ML exploit generation error:', error.message);
      return { success: false, message: 'Exploit generation unavailable' };
    }
  }

  fallbackTargetAnalysis(targetData) {
    const techStack = [];
    const host = targetData.host.toLowerCase();
    
    if (host.includes('api')) techStack.push('REST API');
    if (targetData.protocol === 'https') techStack.push('TLS');
    
    return {
      success: true,
      fallback: true,
      technology: techStack,
      attackSurface: {
        webEndpoints: true,
        apiEndpoints: host.includes('api'),
        authRequired: targetData.authentication?.type !== 'none'
      },
      recommendations: [
        'Perform subdomain enumeration',
        'Check for exposed sensitive endpoints',
        'Test authentication mechanisms'
      ]
    };
  }

  fallbackAttackPlan(target, testType) {
    const plans = {
      reconnaissance: [
        { phase: 'DNS Enumeration', techniques: ['subdomain_bruteforce', 'zone_transfer'] },
        { phase: 'Port Scanning', techniques: ['syn_scan', 'service_detection'] },
        { phase: 'Web Fingerprinting', techniques: ['technology_detection', 'waf_detection'] }
      ],
      vulnerability_scan: [
        { phase: 'Automated Scanning', techniques: ['owasp_top10', 'cve_checks'] },
        { phase: 'Manual Testing', techniques: ['logic_flaws', 'auth_bypass'] }
      ],
      full_pentest: [
        { phase: 'Reconnaissance', techniques: ['osint', 'enumeration'] },
        { phase: 'Vulnerability Assessment', techniques: ['automated_scan', 'manual_review'] },
        { phase: 'Exploitation', techniques: ['poc_development', 'privilege_escalation'] },
        { phase: 'Post-Exploitation', techniques: ['lateral_movement', 'data_exfil'] }
      ]
    };

    return {
      success: true,
      fallback: true,
      plan: plans[testType] || plans.vulnerability_scan,
      estimatedDuration: testType === 'full_pentest' ? 7200 : 3600
    };
  }

  fallbackVulnAnalysis(finding) {
    const severityScores = { critical: 9.5, high: 7.5, medium: 5.5, low: 3.0, info: 1.0 };
    
    return {
      success: true,
      fallback: true,
      cvssScore: severityScores[finding.severity] || 5.0,
      exploitability: finding.severity === 'critical' ? 'high' : 'medium',
      impact: finding.severity === 'critical' || finding.severity === 'high' ? 'significant' : 'moderate',
      recommendations: [
        'Apply vendor patches if available',
        'Implement compensating controls',
        'Monitor for exploitation attempts'
      ]
    };
  }
}

module.exports = new MLService();
