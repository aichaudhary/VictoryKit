const mongoose = require('mongoose');

const engagementSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  engagementId: {
    type: String,
    required: true,
    unique: true,
    index: true
  },
  // Engagement Details
  name: {
    type: String,
    required: true,
    trim: true
  },
  description: String,
  engagementType: {
    type: String,
    enum: ['black_box', 'gray_box', 'white_box', 'red_team', 'purple_team', 'physical', 'social_engineering'],
    required: true
  },
  // Scope Definition
  scope: {
    targets: [{
      type: {
        type: String,
        enum: ['ip', 'ip_range', 'domain', 'subdomain', 'url', 'application', 'network', 'wireless', 'physical'],
        required: true
      },
      value: { type: String, required: true },
      description: String,
      inScope: { type: Boolean, default: true },
      priority: { type: String, enum: ['critical', 'high', 'medium', 'low'], default: 'medium' }
    }],
    exclusions: [{
      type: String,
      value: String,
      reason: String
    }],
    methodology: {
      type: String,
      enum: ['OWASP', 'PTES', 'OSSTMM', 'NIST', 'custom'],
      default: 'PTES'
    },
    rules: {
      allowDenialOfService: { type: Boolean, default: false },
      allowSocialEngineering: { type: Boolean, default: false },
      allowPhysicalAccess: { type: Boolean, default: false },
      allowDataExfiltration: { type: Boolean, default: false },
      workingHours: {
        enabled: { type: Boolean, default: false },
        start: String, // "09:00"
        end: String,   // "17:00"
        timezone: String
      },
      notificationRequired: { type: Boolean, default: true }
    }
  },
  // Client Information
  client: {
    name: String,
    contactName: String,
    contactEmail: String,
    contactPhone: String,
    emergencyContact: String
  },
  // Timeline
  timeline: {
    startDate: { type: Date, required: true },
    endDate: { type: Date, required: true },
    reportDueDate: Date,
    phases: [{
      name: String,
      startDate: Date,
      endDate: Date,
      status: { type: String, enum: ['pending', 'in_progress', 'completed', 'skipped'], default: 'pending' }
    }]
  },
  // Team
  team: [{
    userId: mongoose.Schema.Types.ObjectId,
    name: String,
    role: { type: String, enum: ['lead', 'operator', 'analyst', 'observer'], default: 'operator' },
    permissions: [String]
  }],
  // Status
  status: {
    type: String,
    enum: ['draft', 'approved', 'in_progress', 'paused', 'completed', 'cancelled', 'report_pending'],
    default: 'draft',
    index: true
  },
  // Progress Tracking
  progress: {
    reconnaissance: { status: String, percentage: { type: Number, default: 0 } },
    scanning: { status: String, percentage: { type: Number, default: 0 } },
    enumeration: { status: String, percentage: { type: Number, default: 0 } },
    exploitation: { status: String, percentage: { type: Number, default: 0 } },
    postExploitation: { status: String, percentage: { type: Number, default: 0 } },
    reporting: { status: String, percentage: { type: Number, default: 0 } },
    overall: { type: Number, default: 0 }
  },
  // Findings Summary
  findings: {
    critical: { type: Number, default: 0 },
    high: { type: Number, default: 0 },
    medium: { type: Number, default: 0 },
    low: { type: Number, default: 0 },
    info: { type: Number, default: 0 },
    total: { type: Number, default: 0 },
    exploited: { type: Number, default: 0 }
  },
  // Attack Statistics
  statistics: {
    hostsDiscovered: { type: Number, default: 0 },
    servicesDiscovered: { type: Number, default: 0 },
    vulnerabilitiesFound: { type: Number, default: 0 },
    exploitsAttempted: { type: Number, default: 0 },
    exploitsSuccessful: { type: Number, default: 0 },
    credentialsObtained: { type: Number, default: 0 },
    shellsObtained: { type: Number, default: 0 },
    dataExfiltrated: { type: Number, default: 0 }, // in bytes
    pivotPoints: { type: Number, default: 0 }
  },
  // Credentials Vault (encrypted)
  credentials: [{
    service: String,
    username: String,
    passwordHash: String, // Store hashed, not plaintext
    accessLevel: String,
    source: String, // How it was obtained
    validatedAt: Date
  }],
  // Configuration
  config: {
    autoExploit: { type: Boolean, default: false },
    stealthMode: { type: Boolean, default: true },
    maxConcurrentAttacks: { type: Number, default: 5 },
    reportFormat: { type: String, enum: ['pdf', 'html', 'docx', 'markdown'], default: 'pdf' },
    evidenceCapture: { type: Boolean, default: true }
  },
  // Tags and metadata
  tags: [String],
  notes: String,
  attachments: [{
    name: String,
    type: String,
    url: String,
    uploadedAt: Date
  }]
}, {
  timestamps: true,
  collection: 'engagements'
});

// Indexes
engagementSchema.index({ userId: 1, status: 1 });
engagementSchema.index({ 'timeline.startDate': 1, 'timeline.endDate': 1 });
engagementSchema.index({ createdAt: -1 });

// Virtual for duration
engagementSchema.virtual('duration').get(function() {
  if (this.timeline.startDate && this.timeline.endDate) {
    return Math.ceil((this.timeline.endDate - this.timeline.startDate) / (1000 * 60 * 60 * 24));
  }
  return 0;
});

// Virtual for risk score
engagementSchema.virtual('riskScore').get(function() {
  return (this.findings.critical * 40) + (this.findings.high * 25) + 
         (this.findings.medium * 10) + (this.findings.low * 3);
});

// Method to update progress
engagementSchema.methods.updateProgress = function() {
  const phases = ['reconnaissance', 'scanning', 'enumeration', 'exploitation', 'postExploitation', 'reporting'];
  let total = 0;
  phases.forEach(phase => {
    total += this.progress[phase]?.percentage || 0;
  });
  this.progress.overall = Math.round(total / phases.length);
  return this.save();
};

// Method to add finding
engagementSchema.methods.addFinding = function(severity) {
  const severityMap = { critical: 'critical', high: 'high', medium: 'medium', low: 'low', info: 'info' };
  const key = severityMap[severity.toLowerCase()] || 'info';
  this.findings[key] += 1;
  this.findings.total += 1;
  return this.save();
};

module.exports = mongoose.model('Engagement', engagementSchema);
