const mongoose = require('mongoose');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ’€ EXPLOIT MODEL - Manages exploit database and execution history
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const exploitSchema = new mongoose.Schema({
  // Basic Identification
  exploitId: {
    type: String,
    required: true,
    unique: true,
    index: true
  },
  name: {
    type: String,
    required: true,
    trim: true
  },
  aliases: [String],
  
  // Classification
  category: {
    type: String,
    enum: [
      'remote_code_execution',
      'local_privilege_escalation',
      'denial_of_service',
      'sql_injection',
      'command_injection',
      'buffer_overflow',
      'authentication_bypass',
      'information_disclosure',
      'cross_site_scripting',
      'file_inclusion',
      'deserialization',
      'ssrf',
      'xxe',
      'path_traversal',
      'credential_theft',
      'lateral_movement',
      'persistence',
      'other'
    ],
    required: true
  },
  
  // Severity & Impact
  severity: {
    type: String,
    enum: ['critical', 'high', 'medium', 'low', 'info'],
    required: true
  },
  cvssScore: {
    type: Number,
    min: 0,
    max: 10
  },
  cvssVector: String,
  
  // Affected Systems
  affectedSystems: {
    platforms: [{
      type: String,
      enum: ['windows', 'linux', 'macos', 'unix', 'ios', 'android', 'web', 'network', 'cloud', 'iot']
    }],
    products: [{
      vendor: String,
      product: String,
      versions: [String]
    }],
    services: [{
      name: String,
      ports: [Number],
      protocols: [String]
    }]
  },
  
  // Vulnerability References
  references: {
    cve: [String],      // CVE-2024-1234
    cwe: [String],      // CWE-89
    edbId: String,      // Exploit-DB ID
    msfModule: String,  // Metasploit module path
    nvd: String,
    urls: [String]
  },
  
  // Exploit Details
  exploitDetails: {
    description: {
      type: String,
      required: true
    },
    technicalDescription: String,
    prerequisites: [String],
    requiredAccess: {
      type: String,
      enum: ['none', 'user', 'admin', 'physical', 'network'],
      default: 'network'
    },
    reliability: {
      type: String,
      enum: ['excellent', 'good', 'normal', 'low', 'unreliable'],
      default: 'normal'
    },
    sideEffects: [String],
    cleanupRequired: { type: Boolean, default: false }
  },
  
  // Payload Configuration
  payloads: [{
    name: String,
    type: { 
      type: String, 
      enum: ['shell', 'meterpreter', 'command', 'custom'] 
    },
    platform: String,
    architecture: { type: String, enum: ['x86', 'x64', 'arm', 'mips', 'any'] },
    code: String,
    options: mongoose.Schema.Types.Mixed
  }],
  
  // Execution Options
  options: [{
    name: { type: String, required: true },
    description: String,
    type: { type: String, enum: ['string', 'number', 'boolean', 'address', 'port', 'path'] },
    required: { type: Boolean, default: false },
    defaultValue: mongoose.Schema.Types.Mixed
  }],
  
  // Source Code/Module
  source: {
    type: { type: String, enum: ['metasploit', 'custom', 'exploitdb', 'nuclei', 'nmap', 'manual'] },
    code: String,
    language: String,
    modulePath: String,
    checksum: String
  },
  
  // Detection & Evasion
  detection: {
    signatures: [String],
    iocIndicators: [String],
    evasionTechniques: [String],
    stealthLevel: {
      type: String,
      enum: ['loud', 'normal', 'quiet', 'stealth'],
      default: 'normal'
    }
  },
  
  // Usage Statistics
  stats: {
    timesUsed: { type: Number, default: 0 },
    successCount: { type: Number, default: 0 },
    failureCount: { type: Number, default: 0 },
    lastUsed: Date,
    avgExecutionTime: Number  // in seconds
  },
  
  // Metadata
  status: {
    type: String,
    enum: ['active', 'deprecated', 'patched', 'testing', 'disabled'],
    default: 'active'
  },
  author: String,
  license: String,
  tags: [String],
  
  // Dates
  disclosureDate: Date,
  publishedAt: Date,
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ’¥ EXPLOIT ATTEMPT MODEL - Tracks individual exploit execution attempts
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const exploitAttemptSchema = new mongoose.Schema({
  userId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User', 
    required: true 
  },
  engagementId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'PenTestEngagement' 
  },
  testId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'PenTest' 
  },
  targetId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'PenTestTarget',
    required: true
  },
  exploitId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'Exploit',
    required: true
  },
  
  // Target Info
  target: {
    host: { type: String, required: true },
    port: Number,
    service: String,
    protocol: String
  },
  
  // Execution Details
  execution: {
    options: mongoose.Schema.Types.Mixed,
    payload: {
      type: String,
      options: mongoose.Schema.Types.Mixed
    },
    startedAt: { type: Date, default: Date.now },
    completedAt: Date,
    duration: Number  // milliseconds
  },
  
  // Result
  result: {
    status: {
      type: String,
      enum: ['success', 'partial', 'failed', 'error', 'timeout', 'blocked'],
      required: true
    },
    accessLevel: {
      type: String,
      enum: ['none', 'user', 'root', 'system', 'admin']
    },
    sessionId: String,
    output: String,
    errorMessage: String,
    evidence: {
      screenshots: [String],
      logs: [String],
      artifacts: [String]
    }
  },
  
  // Post-Exploitation
  postExploitation: {
    actionsPerformed: [{
      action: String,
      result: String,
      timestamp: Date
    }],
    dataExtracted: [String],
    persistenceEstablished: { type: Boolean, default: false },
    lateralMovement: { type: Boolean, default: false }
  },
  
  // Cleanup
  cleanup: {
    performed: { type: Boolean, default: false },
    actions: [String],
    cleanedAt: Date
  },
  
  // Metadata
  notes: String,
  createdAt: { type: Date, default: Date.now }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š INDEXES FOR OPTIMAL QUERY PERFORMANCE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Exploit indexes
exploitSchema.index({ category: 1, severity: 1 });
exploitSchema.index({ 'references.cve': 1 });
exploitSchema.index({ 'references.msfModule': 1 });
exploitSchema.index({ 'affectedSystems.platforms': 1 });
exploitSchema.index({ 'affectedSystems.products.vendor': 1, 'affectedSystems.products.product': 1 });
exploitSchema.index({ status: 1 });
exploitSchema.index({ tags: 1 });
exploitSchema.index({ name: 'text', 'exploitDetails.description': 'text' });
exploitSchema.index({ 'stats.successCount': -1 });

// Exploit Attempt indexes
exploitAttemptSchema.index({ userId: 1, 'execution.startedAt': -1 });
exploitAttemptSchema.index({ engagementId: 1 });
exploitAttemptSchema.index({ testId: 1 });
exploitAttemptSchema.index({ targetId: 1 });
exploitAttemptSchema.index({ exploitId: 1 });
exploitAttemptSchema.index({ 'result.status': 1 });
exploitAttemptSchema.index({ 'target.host': 1, 'execution.startedAt': -1 });
exploitAttemptSchema.index({ createdAt: -1 });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ MIDDLEWARE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

exploitSchema.pre('save', function(next) {
  this.updatedAt = new Date();
  next();
});

// Update exploit stats after attempt
exploitAttemptSchema.post('save', async function() {
  try {
    const Exploit = mongoose.model('Exploit');
    const updateData = {
      $inc: { 'stats.timesUsed': 1 },
      $set: { 'stats.lastUsed': new Date() }
    };
    
    if (this.result.status === 'success') {
      updateData.$inc['stats.successCount'] = 1;
    } else if (this.result.status === 'failed' || this.result.status === 'error') {
      updateData.$inc['stats.failureCount'] = 1;
    }
    
    await Exploit.findByIdAndUpdate(this.exploitId, updateData);
  } catch (error) {
    console.error('Failed to update exploit stats:', error);
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“¤ EXPORTS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const Exploit = mongoose.model('Exploit', exploitSchema);
const ExploitAttempt = mongoose.model('ExploitAttempt', exploitAttemptSchema);

module.exports = { Exploit, ExploitAttempt };
