const mongoose = require('mongoose');

const attackPathSchema = new mongoose.Schema({
  // Reference
  engagementId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Engagement',
    required: true,
    index: true
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  pathId: {
    type: String,
    required: true,
    unique: true
  },
  // Path Details
  name: {
    type: String,
    required: true
  },
  description: String,
  // Attack Chain - ordered steps
  steps: [{
    order: { type: Number, required: true },
    stepId: String,
    name: String,
    type: {
      type: String,
      enum: ['recon', 'scan', 'exploit', 'privilege_escalation', 'lateral_movement', 
             'persistence', 'data_access', 'exfiltration', 'cleanup'],
      required: true
    },
    // Target for this step
    target: {
      type: { type: String, enum: ['host', 'service', 'user', 'application', 'network'] },
      identifier: String,
      ip: String,
      port: Number,
      service: String
    },
    // Technique used
    technique: {
      mitreId: String, // MITRE ATT&CK ID (e.g., T1059)
      mitreTactic: String, // e.g., 'execution', 'persistence'
      name: String,
      description: String
    },
    // Module/tool used
    module: {
      type: String, // 'metasploit', 'custom', 'manual', etc.
      name: String,
      moduleId: mongoose.Schema.Types.ObjectId,
      options: mongoose.Schema.Types.Mixed
    },
    // Execution details
    execution: {
      command: String,
      payload: String,
      output: String,
      artifacts: [String], // Files created, registry keys, etc.
      screenshots: [String]
    },
    // Results
    result: {
      status: { type: String, enum: ['pending', 'running', 'success', 'partial', 'failed', 'skipped'], default: 'pending' },
      accessGained: { type: String, enum: ['none', 'user', 'admin', 'system', 'root'] },
      credentialsObtained: [{
        type: String,
        username: String,
        hash: String
      }],
      dataAccessed: [String],
      pivotEnabled: Boolean
    },
    // Timing
    timing: {
      startTime: Date,
      endTime: Date,
      duration: Number // seconds
    },
    // Evidence
    evidence: [{
      type: { type: String, enum: ['screenshot', 'log', 'file', 'pcap', 'video'] },
      description: String,
      url: String,
      timestamp: Date
    }],
    notes: String
  }],
  // Path Analysis
  analysis: {
    complexity: { type: String, enum: ['trivial', 'low', 'medium', 'high', 'expert'], default: 'medium' },
    stealthLevel: { type: String, enum: ['loud', 'moderate', 'quiet', 'silent'], default: 'moderate' },
    timeRequired: Number, // estimated minutes
    skillRequired: { type: String, enum: ['beginner', 'intermediate', 'advanced', 'expert'], default: 'intermediate' },
    prerequisites: [String],
    likelihood: { type: Number, min: 0, max: 100, default: 50 }, // % chance of success
    impact: { type: String, enum: ['critical', 'high', 'medium', 'low'], default: 'medium' },
    riskScore: { type: Number, min: 0, max: 100 }
  },
  // MITRE ATT&CK Mapping
  mitreMapping: {
    tactics: [String], // Initial Access, Execution, Persistence, etc.
    techniques: [{
      id: String,
      name: String,
      subTechniques: [String]
    }],
    software: [String]
  },
  // Status
  status: {
    type: String,
    enum: ['planned', 'in_progress', 'completed', 'failed', 'abandoned'],
    default: 'planned',
    index: true
  },
  // Success metrics
  metrics: {
    stepsCompleted: { type: Number, default: 0 },
    stepsTotal: { type: Number, default: 0 },
    completionPercentage: { type: Number, default: 0 },
    totalDuration: { type: Number, default: 0 },
    highestAccess: { type: String, enum: ['none', 'user', 'admin', 'system', 'root'], default: 'none' }
  },
  // AI Suggestions
  aiSuggestions: {
    nextSteps: [{
      description: String,
      technique: String,
      confidence: Number,
      reasoning: String
    }],
    alternativePaths: [{
      description: String,
      likelihood: Number
    }],
    riskAssessment: String
  },
  // Tags
  tags: [String],
  isTemplate: { type: Boolean, default: false },
  templateName: String
}, {
  timestamps: true,
  collection: 'attack_paths'
});

// Indexes
attackPathSchema.index({ engagementId: 1, status: 1 });
attackPathSchema.index({ 'steps.technique.mitreId': 1 });
attackPathSchema.index({ isTemplate: 1 });

// Method to add step
attackPathSchema.methods.addStep = function(stepData) {
  const order = this.steps.length + 1;
  this.steps.push({
    order,
    stepId: `STEP-${Date.now()}-${order}`,
    ...stepData
  });
  this.metrics.stepsTotal = this.steps.length;
  return this.save();
};

// Method to update step result
attackPathSchema.methods.updateStepResult = function(stepOrder, result) {
  const step = this.steps.find(s => s.order === stepOrder);
  if (step) {
    step.result = { ...step.result, ...result };
    step.timing.endTime = new Date();
    if (step.timing.startTime) {
      step.timing.duration = Math.round((step.timing.endTime - step.timing.startTime) / 1000);
    }
    
    // Update metrics
    if (result.status === 'success' || result.status === 'partial') {
      this.metrics.stepsCompleted = this.steps.filter(s => 
        s.result.status === 'success' || s.result.status === 'partial'
      ).length;
    }
    this.metrics.completionPercentage = Math.round((this.metrics.stepsCompleted / this.metrics.stepsTotal) * 100);
    
    // Update highest access
    const accessLevels = ['none', 'user', 'admin', 'system', 'root'];
    if (result.accessGained) {
      const currentLevel = accessLevels.indexOf(this.metrics.highestAccess);
      const newLevel = accessLevels.indexOf(result.accessGained);
      if (newLevel > currentLevel) {
        this.metrics.highestAccess = result.accessGained;
      }
    }
  }
  return this.save();
};

// Method to calculate risk score
attackPathSchema.methods.calculateRiskScore = function() {
  const impactScores = { critical: 100, high: 75, medium: 50, low: 25 };
  const complexityModifiers = { trivial: 1.2, low: 1.1, medium: 1.0, high: 0.8, expert: 0.6 };
  
  const baseScore = impactScores[this.analysis.impact] || 50;
  const modifier = complexityModifiers[this.analysis.complexity] || 1.0;
  const likelihood = this.analysis.likelihood / 100;
  
  this.analysis.riskScore = Math.round(baseScore * modifier * likelihood);
  return this.save();
};

// Static to find templates
attackPathSchema.statics.findTemplates = function(tags = []) {
  const query = { isTemplate: true };
  if (tags.length > 0) {
    query.tags = { $in: tags };
  }
  return this.find(query).sort({ 'metrics.stepsCompleted': -1 });
};

module.exports = mongoose.model('AttackPath', attackPathSchema);
