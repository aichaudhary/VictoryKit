const mongoose = require('mongoose');

const exploitModuleSchema = new mongoose.Schema({
  // Module Identification
  moduleId: {
    type: String,
    required: true,
    unique: true,
    index: true
  },
  name: {
    type: String,
    required: true,
    index: true
  },
  description: String,
  // Categorization
  category: {
    type: String,
    enum: ['exploit', 'auxiliary', 'post', 'payload', 'encoder', 'nop', 'evasion'],
    required: true,
    index: true
  },
  subcategory: String, // e.g., 'multi/handler', 'windows/smb', 'webapp/php'
  platform: [{
    type: String,
    enum: ['windows', 'linux', 'macos', 'unix', 'android', 'ios', 'multi', 'php', 'java', 'python', 'nodejs', 'ruby']
  }],
  architecture: [{
    type: String,
    enum: ['x86', 'x64', 'arm', 'arm64', 'mips', 'ppc', 'sparc', 'multi']
  }],
  // Vulnerability Information
  vulnerability: {
    cveIds: [String],
    cweIds: [String],
    osvdbIds: [String],
    edbId: String, // Exploit-DB ID
    msb: String,   // Microsoft Security Bulletin
    description: String,
    disclosureDate: Date,
    references: [String]
  },
  // Target Information
  targets: [{
    id: Number,
    name: String,
    platform: String,
    version: String,
    arch: String,
    offset: Number
  }],
  // Required Options
  options: [{
    name: { type: String, required: true },
    type: { type: String, enum: ['string', 'integer', 'boolean', 'address', 'port', 'path', 'enum'], default: 'string' },
    required: { type: Boolean, default: false },
    default: mongoose.Schema.Types.Mixed,
    description: String,
    enumValues: [String]
  }],
  // Payloads (for exploits)
  compatiblePayloads: [{
    name: String,
    platform: String,
    arch: String,
    type: String // reverse_shell, bind_shell, meterpreter, etc.
  }],
  // Reliability & Rankings
  reliability: {
    type: String,
    enum: ['excellent', 'great', 'good', 'normal', 'average', 'low', 'manual'],
    default: 'normal'
  },
  rank: {
    type: Number, // 0-500, higher = more reliable
    default: 100
  },
  sideEffects: [{
    type: String,
    enum: ['crash', 'ioc', 'artifacts', 'account_lockout', 'service_restart', 'data_loss']
  }],
  // Stealth Characteristics
  stealth: {
    noisy: { type: Boolean, default: false },
    requiresAuth: { type: Boolean, default: false },
    networkTraffic: { type: String, enum: ['minimal', 'moderate', 'high'], default: 'moderate' },
    diskWrite: { type: Boolean, default: false },
    memoryOnly: { type: Boolean, default: false }
  },
  // Privilege Requirements
  privileges: {
    required: { type: String, enum: ['none', 'user', 'admin', 'system', 'root'], default: 'none' },
    gained: { type: String, enum: ['none', 'user', 'admin', 'system', 'root'], default: 'none' }
  },
  // Source
  source: {
    type: { type: String, enum: ['metasploit', 'exploitdb', 'custom', 'nuclei', 'internal'], default: 'internal' },
    path: String, // Path in Metasploit or file path
    author: String,
    lastUpdated: Date,
    version: String
  },
  // Usage Statistics
  statistics: {
    timesUsed: { type: Number, default: 0 },
    successCount: { type: Number, default: 0 },
    failureCount: { type: Number, default: 0 },
    successRate: { type: Number, default: 0 },
    avgExecutionTime: { type: Number, default: 0 }, // in seconds
    lastUsed: Date
  },
  // Status
  status: {
    type: String,
    enum: ['active', 'deprecated', 'testing', 'disabled'],
    default: 'active',
    index: true
  },
  verified: { type: Boolean, default: false },
  // AI Enhancement
  aiSuggestions: {
    targetPriority: Number, // 0-100, how likely to be used
    similarModules: [String],
    chainableWith: [String], // Modules that work well after this one
    requiredPreconditions: [String]
  },
  tags: [String]
}, {
  timestamps: true,
  collection: 'exploit_modules'
});

// Indexes
exploitModuleSchema.index({ category: 1, platform: 1 });
exploitModuleSchema.index({ 'vulnerability.cveIds': 1 });
exploitModuleSchema.index({ 'statistics.successRate': -1 });
exploitModuleSchema.index({ name: 'text', description: 'text' });

// Virtual for success rate calculation
exploitModuleSchema.virtual('calculatedSuccessRate').get(function() {
  const total = this.statistics.successCount + this.statistics.failureCount;
  return total > 0 ? Math.round((this.statistics.successCount / total) * 100) : 0;
});

// Method to record usage
exploitModuleSchema.methods.recordUsage = function(success, executionTime) {
  this.statistics.timesUsed += 1;
  if (success) {
    this.statistics.successCount += 1;
  } else {
    this.statistics.failureCount += 1;
  }
  
  const total = this.statistics.successCount + this.statistics.failureCount;
  this.statistics.successRate = Math.round((this.statistics.successCount / total) * 100);
  
  // Update average execution time
  const prevTotal = this.statistics.timesUsed - 1;
  this.statistics.avgExecutionTime = 
    (this.statistics.avgExecutionTime * prevTotal + executionTime) / this.statistics.timesUsed;
  
  this.statistics.lastUsed = new Date();
  return this.save();
};

// Static method to find by CVE
exploitModuleSchema.statics.findByCVE = function(cveId) {
  return this.find({ 'vulnerability.cveIds': cveId, status: 'active' }).sort({ 'statistics.successRate': -1 });
};

// Static method to find compatible exploits for a target
exploitModuleSchema.statics.findForTarget = function(platform, service, version) {
  return this.find({
    status: 'active',
    category: 'exploit',
    platform: { $in: [platform, 'multi'] },
    $or: [
      { subcategory: new RegExp(service, 'i') },
      { name: new RegExp(service, 'i') }
    ]
  }).sort({ rank: -1, 'statistics.successRate': -1 });
};

module.exports = mongoose.model('ExploitModule', exploitModuleSchema);
