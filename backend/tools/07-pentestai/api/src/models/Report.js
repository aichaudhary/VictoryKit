const mongoose = require('mongoose');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“„ REPORT MODEL - Manages penetration test reports
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const reportSchema = new mongoose.Schema({
  userId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User', 
    required: true 
  },
  engagementId: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'PenTestEngagement',
    required: true
  },
  
  // Report Identification
  reportNumber: {
    type: String,
    required: true,
    unique: true
  },
  title: {
    type: String,
    required: true,
    trim: true
  },
  version: {
    type: String,
    default: '1.0'
  },
  
  // Report Type
  reportType: {
    type: String,
    enum: [
      'executive_summary',
      'technical_report',
      'vulnerability_assessment',
      'full_pentest_report',
      'remediation_report',
      'retest_report',
      'compliance_report',
      'custom'
    ],
    required: true
  },
  
  // Classification
  classification: {
    level: {
      type: String,
      enum: ['public', 'internal', 'confidential', 'restricted', 'top_secret'],
      default: 'confidential'
    },
    handling: String,
    distribution: [String]
  },
  
  // Executive Summary
  executiveSummary: {
    overview: String,
    keyFindings: [String],
    riskRating: {
      type: String,
      enum: ['critical', 'high', 'medium', 'low', 'minimal']
    },
    recommendations: [String],
    aiGenerated: { type: Boolean, default: false }
  },
  
  // Scope & Methodology
  scope: {
    description: String,
    targets: [{
      targetId: { type: mongoose.Schema.Types.ObjectId, ref: 'PenTestTarget' },
      name: String,
      type: String,
      scope: String
    }],
    testingDates: {
      start: Date,
      end: Date
    },
    limitations: [String],
    exclusions: [String]
  },
  
  methodology: {
    framework: {
      type: String,
      enum: ['owasp', 'ptes', 'osstmm', 'nist', 'custom'],
      default: 'ptes'
    },
    phases: [{
      name: String,
      description: String,
      tools: [String],
      techniques: [String]
    }]
  },
  
  // Findings Summary
  findingsSummary: {
    total: { type: Number, default: 0 },
    critical: { type: Number, default: 0 },
    high: { type: Number, default: 0 },
    medium: { type: Number, default: 0 },
    low: { type: Number, default: 0 },
    informational: { type: Number, default: 0 },
    
    byCategory: [{
      category: String,
      count: Number
    }],
    
    topRisks: [{
      findingId: { type: mongoose.Schema.Types.ObjectId, ref: 'PenTestFinding' },
      title: String,
      severity: String,
      impact: String
    }]
  },
  
  // Detailed Findings (linked)
  findings: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'PenTestFinding'
  }],
  
  // Risk Assessment
  riskAssessment: {
    overallRiskScore: { type: Number, min: 0, max: 100 },
    riskMatrix: {
      critical: { likelihood: Number, impact: Number },
      high: { likelihood: Number, impact: Number },
      medium: { likelihood: Number, impact: Number },
      low: { likelihood: Number, impact: Number }
    },
    businessImpact: String,
    threatLandscape: String
  },
  
  // Compliance Mapping
  compliance: {
    frameworks: [{
      name: String,
      version: String,
      controlsTested: Number,
      controlsPassed: Number,
      controlsFailed: Number,
      findings: [{
        controlId: String,
        controlName: String,
        status: { type: String, enum: ['pass', 'fail', 'partial', 'not_applicable'] },
        findingId: { type: mongoose.Schema.Types.ObjectId, ref: 'PenTestFinding' }
      }]
    }]
  },
  
  // Recommendations
  recommendations: {
    immediate: [{
      title: String,
      description: String,
      priority: { type: Number, min: 1, max: 5 },
      effort: { type: String, enum: ['low', 'medium', 'high'] },
      relatedFindings: [{ type: mongoose.Schema.Types.ObjectId, ref: 'PenTestFinding' }]
    }],
    shortTerm: [{
      title: String,
      description: String,
      timeline: String,
      effort: { type: String, enum: ['low', 'medium', 'high'] }
    }],
    longTerm: [{
      title: String,
      description: String,
      timeline: String,
      strategicValue: String
    }]
  },
  
  // Appendices
  appendices: [{
    title: String,
    type: { type: String, enum: ['tool_output', 'evidence', 'methodology', 'glossary', 'references', 'other'] },
    content: String,
    attachments: [{
      name: String,
      type: String,
      url: String,
      size: Number
    }]
  }],
  
  // Report Generation
  generation: {
    template: String,
    format: {
      type: String,
      enum: ['pdf', 'docx', 'html', 'markdown', 'json'],
      default: 'pdf'
    },
    generatedAt: Date,
    generatedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    aiAssisted: { type: Boolean, default: false },
    fileUrl: String,
    fileSize: Number,
    checksum: String
  },
  
  // Review & Approval
  review: {
    status: {
      type: String,
      enum: ['draft', 'in_review', 'approved', 'rejected', 'published'],
      default: 'draft'
    },
    reviewers: [{
      userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
      status: { type: String, enum: ['pending', 'approved', 'changes_requested'] },
      comments: String,
      reviewedAt: Date
    }],
    approvedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    approvedAt: Date,
    publishedAt: Date
  },
  
  // Version History
  versions: [{
    version: String,
    changes: String,
    createdAt: { type: Date, default: Date.now },
    createdBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
    fileUrl: String
  }],
  
  // Delivery
  delivery: {
    recipients: [{
      email: String,
      name: String,
      deliveredAt: Date,
      method: { type: String, enum: ['email', 'portal', 'secure_transfer'] }
    }],
    accessLog: [{
      userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
      accessedAt: Date,
      action: { type: String, enum: ['view', 'download', 'print'] },
      ipAddress: String
    }]
  },
  
  // Metadata
  tags: [String],
  notes: String,
  
  // Audit Trail
  createdAt: { type: Date, default: Date.now },
  updatedAt: { type: Date, default: Date.now },
  createdBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
  lastModifiedBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“Š INDEXES FOR OPTIMAL QUERY PERFORMANCE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Primary lookup indexes
reportSchema.index({ userId: 1, 'review.status': 1 });
reportSchema.index({ engagementId: 1 });
reportSchema.index({ reportNumber: 1 });

// Status and type queries
reportSchema.index({ reportType: 1, 'review.status': 1 });
reportSchema.index({ 'review.status': 1, createdAt: -1 });

// Risk and findings queries
reportSchema.index({ 'riskAssessment.overallRiskScore': -1 });
reportSchema.index({ 'findingsSummary.critical': -1, 'findingsSummary.high': -1 });

// Timeline queries
reportSchema.index({ createdAt: -1 });
reportSchema.index({ 'review.publishedAt': -1 });

// Search index
reportSchema.index({ title: 'text', 'executiveSummary.overview': 'text' });

// Compound indexes
reportSchema.index({ userId: 1, reportType: 1, createdAt: -1 });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ”§ MIDDLEWARE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

reportSchema.pre('save', function(next) {
  this.updatedAt = new Date();
  next();
});

// Auto-generate report number
reportSchema.pre('save', async function(next) {
  if (!this.reportNumber) {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const count = await mongoose.model('PenTestReport').countDocuments({
      createdAt: {
        $gte: new Date(year, date.getMonth(), 1),
        $lt: new Date(year, date.getMonth() + 1, 1)
      }
    });
    this.reportNumber = `PTR-${year}${month}-${String(count + 1).padStart(4, '0')}`;
  }
  next();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“¤ EXPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

module.exports = mongoose.model('PenTestReport', reportSchema);
