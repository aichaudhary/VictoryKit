const Test = require('../models/Test');
const Target = require('../models/Target');
const Finding = require('../models/Finding');
const pentestService = require('../services/pentestService');
const mlService = require('../services/mlService');
const { ApiResponse, ApiError } = require('../../../../../shared');

exports.createTest = async (req, res, next) => {
  try {
    const { targetId, testType, configuration } = req.body;

    const target = await Target.findOne({
      _id: targetId,
      userId: req.user.id
    });

    if (!target) {
      throw new ApiError(404, 'Target not found');
    }

    // Generate AI attack plan
    const attackPlan = await mlService.generateAttackPlan(target, testType);

    const test = await Test.create({
      userId: req.user.id,
      targetId,
      testType,
      configuration: {
        ...configuration,
        techniques: attackPlan.plan?.map(p => p.techniques).flat() || []
      },
      phases: attackPlan.plan?.map(p => ({
        name: p.phase,
        status: 'pending'
      })) || []
    });

    // Update target status
    target.status = 'testing';
    await target.save();

    res.status(201).json(ApiResponse.success({
      test,
      attackPlan
    }, 'Penetration test created'));
  } catch (error) {
    next(error);
  }
};

exports.getTests = async (req, res, next) => {
  try {
    const { status, targetId, page = 1, limit = 20 } = req.query;
    const filter = { userId: req.user.id };

    if (status) filter.status = status;
    if (targetId) filter.targetId = targetId;

    const tests = await Test.find(filter)
      .populate('targetId', 'name host type')
      .sort({ createdAt: -1 })
      .skip((page - 1) * limit)
      .limit(parseInt(limit));

    const total = await Test.countDocuments(filter);

    res.json(ApiResponse.success({
      tests,
      pagination: { page: parseInt(page), limit: parseInt(limit), total }
    }));
  } catch (error) {
    next(error);
  }
};

exports.getTest = async (req, res, next) => {
  try {
    const test = await Test.findOne({
      _id: req.params.id,
      userId: req.user.id
    }).populate('targetId');

    if (!test) {
      throw new ApiError(404, 'Test not found');
    }

    const findings = await Finding.find({ testId: test._id })
      .sort({ severity: 1 });

    res.json(ApiResponse.success({ test, findings }));
  } catch (error) {
    next(error);
  }
};

exports.startTest = async (req, res, next) => {
  try {
    const test = await Test.findOne({
      _id: req.params.id,
      userId: req.user.id
    });

    if (!test) {
      throw new ApiError(404, 'Test not found');
    }

    if (test.status === 'running') {
      throw new ApiError(400, 'Test already running');
    }

    const target = await Target.findById(test.targetId);
    
    test.status = 'running';
    test.startedAt = new Date();
    test.progress = 0;
    await test.save();

    // Trigger external security integrations
    mlService.integrateWithSecurityStack(test._id, {
      target: target.host || target.name,
      testType: test.testType,
      userId: req.user.id
    }).catch(error => {
      console.error('Integration error:', error);
      // Don't fail the test if integration fails
    });

    // Run test phases asynchronously
    this.executeTestPhases(test, target).catch(console.error);

    res.json(ApiResponse.success(test, 'Test started'));
  } catch (error) {
    next(error);
  }
};

exports.executeTestPhases = async (test, target) => {
  try {
    const phases = test.phases;
    
    for (let i = 0; i < phases.length; i++) {
      phases[i].status = 'running';
      phases[i].startedAt = new Date();
      test.progress = Math.round((i / phases.length) * 100);
      await test.save();

      let phaseResults;
      
      if (phases[i].name.toLowerCase().includes('recon')) {
        phaseResults = await pentestService.performReconnaissance(target);
      } else {
        phaseResults = await pentestService.runVulnerabilityScan(target, test.configuration);
      }

      // Save findings
      for (const finding of phaseResults.findings || []) {
        await Finding.create({
          userId: test.userId,
          testId: test._id,
          targetId: target._id,
          title: finding.title,
          category: finding.category,
          severity: finding.severity,
          description: finding.evidence || finding.details || 'Vulnerability detected',
          technicalDetails: {
            endpoint: finding.endpoint,
            parameter: finding.parameter,
            payload: finding.payload,
            evidence: finding.evidence
          }
        });
      }

      phases[i].status = 'completed';
      phases[i].completedAt = new Date();
      phases[i].findings = phaseResults.findings?.length || 0;
      await test.save();
    }

    // Finalize test
    const allFindings = await Finding.find({ testId: test._id });
    test.status = 'completed';
    test.progress = 100;
    test.completedAt = new Date();
    test.results = pentestService.summarizeFindings(allFindings);
    test.results.vulnerabilities = allFindings.length;
    test.aiInsights.riskScore = pentestService.calculateRiskScore(allFindings);
    await test.save();

    // Update target
    target.status = 'completed';
    target.lastTestedAt = new Date();
    await target.save();

  } catch (error) {
    test.status = 'failed';
    await test.save();
    console.error('Test execution error:', error);
  }
};

exports.stopTest = async (req, res, next) => {
  try {
    const test = await Test.findOneAndUpdate(
      { _id: req.params.id, userId: req.user.id, status: 'running' },
      { status: 'cancelled' },
      { new: true }
    );

    if (!test) {
      throw new ApiError(404, 'Running test not found');
    }

    res.json(ApiResponse.success(test, 'Test stopped'));
  } catch (error) {
    next(error);
  }
};

exports.deleteTest = async (req, res, next) => {
  try {
    const test = await Test.findOneAndDelete({
      _id: req.params.id,
      userId: req.user.id
    });

    if (!test) {
      throw new ApiError(404, 'Test not found');
    }

    await Finding.deleteMany({ testId: test._id });

    res.json(ApiResponse.success(null, 'Test deleted'));
  } catch (error) {
    next(error);
  }
};
