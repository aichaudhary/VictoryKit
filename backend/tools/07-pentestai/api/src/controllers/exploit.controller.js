/**
 * Exploit Controller - Manages exploit modules and execution
 * Handles exploit search, execution, and payload generation
 */

const ExploitModule = require('../models/ExploitModule.model');
const exploitService = require('../services/exploit.service');
const reconService = require('../services/recon.service');
const attackService = require('../services/attack.service');
const logger = require('../../../../../shared/utils/logger');

/**
 * Search for exploits
 */
exports.searchExploits = async (req, res) => {
  try {
    const { query, cve, platform, category, page = 1, limit = 20 } = req.query;

    let results;

    if (cve) {
      // Search by CVE
      results = await exploitService.searchByCVE(cve);
      return res.json({
        success: true,
        data: results
      });
    }

    // Build search query
    const searchQuery = {};

    if (query) {
      searchQuery.$or = [
        { name: new RegExp(query, 'i') },
        { description: new RegExp(query, 'i') },
        { 'vulnerability.cveIds': new RegExp(query, 'i') }
      ];
    }

    if (platform) searchQuery.platform = platform;
    if (category) searchQuery.category = category;

    const skip = (parseInt(page) - 1) * parseInt(limit);

    const [exploits, total] = await Promise.all([
      ExploitModule.find(searchQuery)
        .sort({ 'metrics.successRate': -1 })
        .skip(skip)
        .limit(parseInt(limit))
        .lean(),
      ExploitModule.countDocuments(searchQuery)
    ]);

    res.json({
      success: true,
      data: exploits,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / parseInt(limit))
      }
    });
  } catch (error) {
    logger.error('Search exploits error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

/**
 * Get exploit module details
 */
exports.getExploitDetails = async (req, res) => {
  try {
    const { id } = req.params;

    const exploit = await ExploitModule.findOne({
      $or: [{ _id: id }, { 'source.path': id }]
    });

    if (!exploit) {
      // Try fetching from Metasploit
      const msfModule = await exploitService.getModuleInfo('exploit', id);
      if (msfModule) {
        return res.json({
          success: true,
          data: msfModule,
          source: 'metasploit'
        });
      }

      return res.status(404).json({
        success: false,
        error: 'Exploit module not found'
      });
    }

    res.json({
      success: true,
      data: exploit
    });
  } catch (error) {
    logger.error('Get exploit details error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

/**
 * Execute an exploit module
 */
exports.executeExploit = async (req, res) => {
  try {
    const { id } = req.params;
    const {
      target,
      payload,
      options = {},
      timeout
    } = req.body;

    // Validate required fields
    if (!target || !target.host) {
      return res.status(400).json({
        success: false,
        error: 'Target host is required'
      });
    }

    // Get exploit module
    const exploit = await ExploitModule.findOne({
      $or: [{ _id: id }, { 'source.path': id }]
    });

    const modulePath = exploit?.source?.path || id;
    const moduleType = exploit?.category || 'exploit';

    // Execute exploit
    const result = await exploitService.executeExploit({
      moduleType,
      modulePath,
      target,
      payload,
      moduleOptions: options,
      timeout
    });

    logger.info(`Exploit executed: ${modulePath} against ${target.host}`, {
      success: result.success,
      duration: result.duration
    });

    res.json({
      success: true,
      data: result
    });
  } catch (error) {
    logger.error('Execute exploit error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

/**
 * Generate payload
 */
exports.generatePayload = async (req, res) => {
  try {
    const {
      payload,
      format,
      lhost,
      lport,
      encoder,
      iterations
    } = req.body;

    if (!lhost) {
      return res.status(400).json({
        success: false,
        error: 'LHOST is required'
      });
    }

    const result = await exploitService.generatePayload({
      payload,
      format,
      lhost,
      lport,
      encoder,
      iterations
    });

    res.json({
      success: true,
      data: result
    });
  } catch (error) {
    logger.error('Generate payload error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

/**
 * Get recommended exploits for a target
 */
exports.getRecommendedExploits = async (req, res) => {
  try {
    const { target } = req.body;

    if (!target) {
      return res.status(400).json({
        success: false,
        error: 'Target information is required'
      });
    }

    const recommendations = await exploitService.getRecommendedExploits(target);

    res.json({
      success: true,
      data: recommendations
    });
  } catch (error) {
    logger.error('Get recommended exploits error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

/**
 * Run reconnaissance
 */
exports.runRecon = async (req, res) => {
  try {
    const { target, options = {} } = req.body;

    if (!target) {
      return res.status(400).json({
        success: false,
        error: 'Target is required'
      });
    }

    const results = await reconService.fullRecon(target, options);

    logger.info(`Recon completed for ${target}`, {
      openPorts: results.active?.ports?.openPorts?.length || 0,
      subdomains: results.passive?.subdomains?.length || 0
    });

    res.json({
      success: true,
      data: results
    });
  } catch (error) {
    logger.error('Run recon error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

/**
 * Run port scan
 */
exports.portScan = async (req, res) => {
  try {
    const { target, ports = '1-1000' } = req.body;

    if (!target) {
      return res.status(400).json({
        success: false,
        error: 'Target is required'
      });
    }

    const results = await reconService.portScan(target, ports);

    res.json({
      success: true,
      data: results
    });
  } catch (error) {
    logger.error('Port scan error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

/**
 * Run service detection
 */
exports.serviceDetection = async (req, res) => {
  try {
    const { target, ports = '1-1000' } = req.body;

    if (!target) {
      return res.status(400).json({
        success: false,
        error: 'Target is required'
      });
    }

    const results = await reconService.serviceDetection(target, ports);

    res.json({
      success: true,
      data: results
    });
  } catch (error) {
    logger.error('Service detection error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

/**
 * Run OS fingerprinting
 */
exports.osFingerprint = async (req, res) => {
  try {
    const { target } = req.body;

    if (!target) {
      return res.status(400).json({
        success: false,
        error: 'Target is required'
      });
    }

    const results = await reconService.osFingerprint(target);

    res.json({
      success: true,
      data: results
    });
  } catch (error) {
    logger.error('OS fingerprint error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

/**
 * Run web reconnaissance
 */
exports.webRecon = async (req, res) => {
  try {
    const { target } = req.body;

    if (!target) {
      return res.status(400).json({
        success: false,
        error: 'Target is required'
      });
    }

    const results = await reconService.webRecon(target);

    res.json({
      success: true,
      data: results
    });
  } catch (error) {
    logger.error('Web recon error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

/**
 * Run SQL injection test
 */
exports.sqlInjection = async (req, res) => {
  try {
    const { target, data, cookie } = req.body;

    if (!target) {
      return res.status(400).json({
        success: false,
        error: 'Target URL is required'
      });
    }

    const results = await attackService.testSQLInjection(target, { data, cookie });

    res.json({
      success: true,
      data: results
    });
  } catch (error) {
    logger.error('SQL injection test error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

/**
 * Run brute force attack
 */
exports.bruteForce = async (req, res) => {
  try {
    const { target, service, username, userlist, passwordlist, threads } = req.body;

    if (!target) {
      return res.status(400).json({
        success: false,
        error: 'Target is required'
      });
    }

    const results = await attackService.bruteForce(target, {
      service,
      username,
      userlist,
      passwordlist,
      threads
    });

    res.json({
      success: true,
      data: results
    });
  } catch (error) {
    logger.error('Brute force error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

/**
 * Create/Update exploit module in database
 */
exports.createExploitModule = async (req, res) => {
  try {
    const moduleData = req.body;

    // Generate module ID if not provided
    if (!moduleData.moduleId) {
      moduleData.moduleId = `MOD-${Date.now()}-${Math.random().toString(36).substr(2, 6).toUpperCase()}`;
    }

    const existingModule = await ExploitModule.findOne({
      $or: [
        { moduleId: moduleData.moduleId },
        { 'source.path': moduleData.source?.path }
      ]
    });

    if (existingModule) {
      // Update existing
      Object.assign(existingModule, moduleData);
      await existingModule.save();
      return res.json({
        success: true,
        data: existingModule,
        message: 'Exploit module updated'
      });
    }

    // Create new
    const exploit = new ExploitModule(moduleData);
    await exploit.save();

    res.status(201).json({
      success: true,
      data: exploit,
      message: 'Exploit module created'
    });
  } catch (error) {
    logger.error('Create exploit module error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

/**
 * Delete exploit module
 */
exports.deleteExploitModule = async (req, res) => {
  try {
    const { id } = req.params;

    const result = await ExploitModule.findOneAndDelete({
      $or: [{ _id: id }, { moduleId: id }]
    });

    if (!result) {
      return res.status(404).json({
        success: false,
        error: 'Exploit module not found'
      });
    }

    res.json({
      success: true,
      message: 'Exploit module deleted'
    });
  } catch (error) {
    logger.error('Delete exploit module error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

/**
 * Get exploit statistics
 */
exports.getExploitStats = async (req, res) => {
  try {
    const [
      totalModules,
      byCategory,
      byPlatform,
      topSuccessful
    ] = await Promise.all([
      ExploitModule.countDocuments(),
      ExploitModule.aggregate([
        { $group: { _id: '$category', count: { $sum: 1 } } },
        { $sort: { count: -1 } }
      ]),
      ExploitModule.aggregate([
        { $group: { _id: '$platform', count: { $sum: 1 } } },
        { $sort: { count: -1 } }
      ]),
      ExploitModule.find()
        .sort({ 'metrics.successRate': -1 })
        .limit(10)
        .select('name platform category metrics.successRate metrics.totalAttempts')
        .lean()
    ]);

    res.json({
      success: true,
      data: {
        totalModules,
        byCategory,
        byPlatform,
        topSuccessful
      }
    });
  } catch (error) {
    logger.error('Get exploit stats error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

/**
 * Sync exploits from Metasploit
 */
exports.syncFromMetasploit = async (req, res) => {
  try {
    // This would sync the local database with Metasploit modules
    // For now, return a placeholder response
    res.json({
      success: true,
      message: 'Metasploit sync initiated',
      data: {
        status: 'pending',
        note: 'Full sync requires Metasploit RPC connection'
      }
    });
  } catch (error) {
    logger.error('Sync from Metasploit error:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};
