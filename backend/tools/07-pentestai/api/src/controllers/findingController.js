const Finding = require('../models/Finding');
const mlService = require('../services/mlService');
const { ApiResponse, ApiError } = require('../../../../shared');

exports.getFindings = async (req, res, next) => {
  try {
    const { testId, severity, category, status, page = 1, limit = 50 } = req.query;
    const filter = { userId: req.user.id };

    if (testId) filter.testId = testId;
    if (severity) filter.severity = severity;
    if (category) filter.category = category;
    if (status) filter.status = status;

    const findings = await Finding.find(filter)
      .populate('testId', 'testType status')
      .populate('targetId', 'name host')
      .sort({ severity: 1, createdAt: -1 })
      .skip((page - 1) * limit)
      .limit(parseInt(limit));

    const total = await Finding.countDocuments(filter);

    res.json(ApiResponse.success({
      findings,
      pagination: { page: parseInt(page), limit: parseInt(limit), total }
    }));
  } catch (error) {
    next(error);
  }
};

exports.getFinding = async (req, res, next) => {
  try {
    const finding = await Finding.findOne({
      _id: req.params.id,
      userId: req.user.id
    })
      .populate('testId')
      .populate('targetId');

    if (!finding) {
      throw new ApiError(404, 'Finding not found');
    }

    res.json(ApiResponse.success(finding));
  } catch (error) {
    next(error);
  }
};

exports.updateFinding = async (req, res, next) => {
  try {
    const { status, remediation } = req.body;
    const updates = {};

    if (status) {
      updates.status = status;
      if (status === 'confirmed') updates.verifiedAt = new Date();
    }
    if (remediation) updates.remediation = remediation;

    const finding = await Finding.findOneAndUpdate(
      { _id: req.params.id, userId: req.user.id },
      updates,
      { new: true }
    );

    if (!finding) {
      throw new ApiError(404, 'Finding not found');
    }

    res.json(ApiResponse.success(finding, 'Finding updated'));
  } catch (error) {
    next(error);
  }
};

exports.analyzeFinding = async (req, res, next) => {
  try {
    const finding = await Finding.findOne({
      _id: req.params.id,
      userId: req.user.id
    });

    if (!finding) {
      throw new ApiError(404, 'Finding not found');
    }

    const analysis = await mlService.analyzeVulnerability({
      title: finding.title,
      category: finding.category,
      severity: finding.severity,
      technicalDetails: finding.technicalDetails
    });

    if (analysis.cvssScore) {
      finding.cvssScore = analysis.cvssScore;
    }
    
    finding.remediation = finding.remediation || {};
    finding.remediation.recommendations = analysis.recommendations;
    await finding.save();

    res.json(ApiResponse.success({
      finding,
      analysis
    }, 'Finding analyzed'));
  } catch (error) {
    next(error);
  }
};

exports.generateExploit = async (req, res, next) => {
  try {
    const finding = await Finding.findOne({
      _id: req.params.id,
      userId: req.user.id
    });

    if (!finding) {
      throw new ApiError(404, 'Finding not found');
    }

    if (!['critical', 'high'].includes(finding.severity)) {
      throw new ApiError(400, 'Exploit generation only for critical/high severity');
    }

    const exploit = await mlService.generateExploit({
      category: finding.category,
      technicalDetails: finding.technicalDetails
    });

    if (exploit.success && exploit.code) {
      finding.exploitation = finding.exploitation || {};
      finding.exploitation.exploitAvailable = true;
      finding.exploitation.exploitCode = exploit.code;
      await finding.save();
    }

    res.json(ApiResponse.success({
      finding,
      exploit
    }, 'Exploit generated'));
  } catch (error) {
    next(error);
  }
};

exports.getStats = async (req, res, next) => {
  try {
    const stats = await Finding.aggregate([
      { $match: { userId: req.user.id } },
      {
        $group: {
          _id: null,
          total: { $sum: 1 },
          critical: { $sum: { $cond: [{ $eq: ['$severity', 'critical'] }, 1, 0] } },
          high: { $sum: { $cond: [{ $eq: ['$severity', 'high'] }, 1, 0] } },
          medium: { $sum: { $cond: [{ $eq: ['$severity', 'medium'] }, 1, 0] } },
          low: { $sum: { $cond: [{ $eq: ['$severity', 'low'] }, 1, 0] } },
          info: { $sum: { $cond: [{ $eq: ['$severity', 'info'] }, 1, 0] } },
          open: { $sum: { $cond: [{ $eq: ['$status', 'open'] }, 1, 0] } },
          remediated: { $sum: { $cond: [{ $eq: ['$status', 'remediated'] }, 1, 0] } }
        }
      }
    ]);

    const categoryStats = await Finding.aggregate([
      { $match: { userId: req.user.id } },
      { $group: { _id: '$category', count: { $sum: 1 } } },
      { $sort: { count: -1 } }
    ]);

    res.json(ApiResponse.success({
      summary: stats[0] || { total: 0 },
      byCategory: categoryStats
    }));
  } catch (error) {
    next(error);
  }
};
