/**
 * PenTestAI API Service
 * Comprehensive API client for penetration testing operations
 */

import axios, { AxiosInstance, AxiosError } from 'axios';

// API Configuration
const API_BASE_URL = import.meta.env.VITE_PENTESTAI_API_URL || 'http://localhost:4007/api';

// Create axios instance with default config
const apiClient: AxiosInstance = axios.create({
  baseURL: API_BASE_URL,
  timeout: 300000, // 5 minutes for long operations
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor for auth token
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('authToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor for error handling
apiClient.interceptors.response.use(
  (response) => response,
  (error: AxiosError) => {
    console.error('API Error:', error.response?.data || error.message);
    return Promise.reject(error);
  }
);

// ==========================================
// TYPE DEFINITIONS
// ==========================================

export interface Engagement {
  _id: string;
  engagementId: string;
  name: string;
  engagementType: 'black_box' | 'gray_box' | 'white_box' | 'red_team' | 'purple_team';
  clientName: string;
  status: 'planned' | 'active' | 'paused' | 'completed' | 'cancelled';
  scope: ScopeItem[];
  rulesOfEngagement: RulesOfEngagement;
  timeline: Timeline;
  team: TeamMember[];
  findings: Finding[];
  riskScore: number;
  createdAt: string;
  updatedAt: string;
}

export interface ScopeItem {
  type: 'ip' | 'cidr' | 'domain' | 'url' | 'application';
  value: string;
  inScope: boolean;
  notes?: string;
}

export interface RulesOfEngagement {
  allowedTechniques: string[];
  prohibitedTechniques: string[];
  testingWindow: { start: string; end: string };
  escalationContacts: { name: string; phone: string; email: string }[];
  methodology: string;
}

export interface Timeline {
  startDate: string;
  endDate: string;
  phases: Phase[];
}

export interface Phase {
  name: string;
  startDate: string;
  endDate: string;
  status: string;
}

export interface TeamMember {
  memberId: string;
  memberName: string;
  role: 'lead' | 'pentester' | 'reviewer' | 'observer';
  permissions: string[];
}

export interface Finding {
  findingId: string;
  title: string;
  severity: 'critical' | 'high' | 'medium' | 'low' | 'informational';
  category: string;
  description: string;
  impact: string;
  remediation: string;
  status: 'open' | 'confirmed' | 'false_positive' | 'remediated' | 'accepted';
  cvss?: { score: number; vector: string };
  evidence: { type: string; content: string }[];
  affectedAssets: string[];
}

export interface AttackPath {
  _id: string;
  pathId: string;
  name: string;
  description?: string;
  status: 'planned' | 'in_progress' | 'completed' | 'failed' | 'aborted';
  steps: AttackStep[];
  riskScore: number;
  metrics: {
    stepsCompleted: number;
    stepsTotal: number;
    progressPercent: number;
  };
}

export interface AttackStep {
  order: number;
  stepId: string;
  name: string;
  type: string;
  technique: {
    mitreId: string;
    mitreTactic: string;
    name: string;
  };
  result: {
    status: string;
    accessGained?: string;
    output?: string;
  };
  timing: {
    duration?: number;
  };
}

export interface ExploitModule {
  _id: string;
  moduleId: string;
  name: string;
  description: string;
  category: string;
  platform: string;
  architecture: string[];
  reliability: 'excellent' | 'good' | 'average' | 'low' | 'manual';
  vulnerability: {
    cveIds: string[];
    cweId?: string;
  };
  metrics: {
    successRate: number;
    totalAttempts: number;
  };
}

export interface ReconResult {
  target: string;
  timestamp: string;
  passive: {
    dns?: DnsResult;
    whois?: Record<string, unknown>;
    subdomains?: string[];
    shodan?: ShodanResult;
  };
  active: {
    ports?: PortScanResult;
    services?: ServiceResult;
    os?: OsResult;
    web?: WebReconResult;
  };
  summary: {
    totalOpenPorts: number;
    totalServices: number;
    subdomainsFound: number;
    os: string;
  };
}

export interface DnsResult {
  records: Record<string, unknown[]>;
  nameservers: string[];
  mailServers: string[];
}

export interface ShodanResult {
  ip: string;
  hostnames: string[];
  ports: number[];
  vulns: string[];
  services: { port: number; product: string; version: string }[];
}

export interface PortScanResult {
  target: string;
  openPorts: { port: number; state: string; protocol: string; service: string }[];
}

export interface ServiceResult {
  target: string;
  services: { port: number; protocol: string; service: string; version: string }[];
}

export interface OsResult {
  target: string;
  os: string;
  guesses: { os: string; confidence: number }[];
}

export interface WebReconResult {
  url: string;
  statusCode: number;
  technologies: { category: string; name: string }[];
  headers: Record<string, string>;
}

export interface ExploitResult {
  success: boolean;
  output: string;
  sessionId?: string;
  error?: string;
  duration: number;
}

export interface ApiResponse<T> {
  success: boolean;
  data: T;
  message?: string;
  error?: string;
  pagination?: {
    page: number;
    limit: number;
    total: number;
    pages: number;
  };
}

// ==========================================
// ENGAGEMENT API
// ==========================================

export const engagementApi = {
  // Create engagement
  create: async (data: Partial<Engagement>): Promise<ApiResponse<Engagement>> => {
    const response = await apiClient.post('/engagements', data);
    return response.data;
  },

  // Get all engagements
  getAll: async (params?: {
    status?: string;
    type?: string;
    page?: number;
    limit?: number;
  }): Promise<ApiResponse<Engagement[]>> => {
    const response = await apiClient.get('/engagements', { params });
    return response.data;
  },

  // Get engagement by ID
  getById: async (id: string): Promise<ApiResponse<Engagement & { attackPaths: AttackPath[] }>> => {
    const response = await apiClient.get(`/engagements/${id}`);
    return response.data;
  },

  // Update engagement
  update: async (id: string, data: Partial<Engagement>): Promise<ApiResponse<Engagement>> => {
    const response = await apiClient.put(`/engagements/${id}`, data);
    return response.data;
  },

  // Delete engagement
  delete: async (id: string): Promise<ApiResponse<null>> => {
    const response = await apiClient.delete(`/engagements/${id}`);
    return response.data;
  },

  // Update status
  updateStatus: async (id: string, status: string): Promise<ApiResponse<Engagement>> => {
    const response = await apiClient.patch(`/engagements/${id}/status`, { status });
    return response.data;
  },

  // Get statistics
  getStats: async (): Promise<ApiResponse<{
    totalEngagements: number;
    activeEngagements: number;
    completedEngagements: number;
    totalFindings: number;
    findingsBySeverity: Record<string, number>;
  }>> => {
    const response = await apiClient.get('/engagements/stats');
    return response.data;
  },

  // Team management
  addTeamMember: async (id: string, member: Partial<TeamMember>): Promise<ApiResponse<TeamMember[]>> => {
    const response = await apiClient.post(`/engagements/${id}/team`, member);
    return response.data;
  },

  removeTeamMember: async (id: string, memberId: string): Promise<ApiResponse<TeamMember[]>> => {
    const response = await apiClient.delete(`/engagements/${id}/team/${memberId}`);
    return response.data;
  },

  // Findings
  addFinding: async (id: string, finding: Partial<Finding>): Promise<ApiResponse<Finding>> => {
    const response = await apiClient.post(`/engagements/${id}/findings`, finding);
    return response.data;
  },

  getFindings: async (id: string, params?: {
    severity?: string;
    category?: string;
  }): Promise<ApiResponse<Finding[]>> => {
    const response = await apiClient.get(`/engagements/${id}/findings`, { params });
    return response.data;
  },

  // Attack paths
  createAttackPath: async (id: string, data: {
    name: string;
    description?: string;
    targets: ScopeItem[];
    methodology?: string;
    stealthMode?: boolean;
  }): Promise<ApiResponse<AttackPath>> => {
    const response = await apiClient.post(`/engagements/${id}/attack-paths`, data);
    return response.data;
  },

  executeAttackPath: async (id: string, pathId: string, options?: Record<string, unknown>): Promise<ApiResponse<{ status: string }>> => {
    const response = await apiClient.post(`/engagements/${id}/attack-paths/${pathId}/execute`, options);
    return response.data;
  },

  getAttackPathStatus: async (id: string, pathId: string): Promise<ApiResponse<AttackPath>> => {
    const response = await apiClient.get(`/engagements/${id}/attack-paths/${pathId}/status`);
    return response.data;
  },

  // Reports
  generateReport: async (id: string, format?: 'json' | 'pdf' | 'html'): Promise<ApiResponse<unknown>> => {
    const response = await apiClient.get(`/engagements/${id}/report`, { params: { format } });
    return response.data;
  },
};

// ==========================================
// EXPLOIT API
// ==========================================

export const exploitApi = {
  // Search exploits
  search: async (params: {
    query?: string;
    cve?: string;
    platform?: string;
    category?: string;
    page?: number;
    limit?: number;
  }): Promise<ApiResponse<ExploitModule[]>> => {
    const response = await apiClient.get('/exploits', { params });
    return response.data;
  },

  // Get exploit details
  getById: async (id: string): Promise<ApiResponse<ExploitModule>> => {
    const response = await apiClient.get(`/exploits/${id}`);
    return response.data;
  },

  // Execute exploit
  execute: async (id: string, data: {
    target: { host: string; port?: number };
    payload?: string;
    options?: Record<string, unknown>;
    timeout?: number;
  }): Promise<ApiResponse<ExploitResult>> => {
    const response = await apiClient.post(`/exploits/${id}/execute`, data);
    return response.data;
  },

  // Get recommendations
  getRecommendations: async (target: {
    os?: string;
    services?: { service: string; version: string; port: number }[];
    vulnerabilities?: { name: string; cveIds?: string[] }[];
  }): Promise<ApiResponse<unknown>> => {
    const response = await apiClient.post('/exploits/recommend', { target });
    return response.data;
  },

  // Get statistics
  getStats: async (): Promise<ApiResponse<{
    totalModules: number;
    byCategory: { _id: string; count: number }[];
    byPlatform: { _id: string; count: number }[];
    topSuccessful: ExploitModule[];
  }>> => {
    const response = await apiClient.get('/exploits/stats');
    return response.data;
  },

  // Sync from Metasploit
  syncFromMetasploit: async (): Promise<ApiResponse<{ status: string }>> => {
    const response = await apiClient.post('/exploits/sync-metasploit');
    return response.data;
  },

  // Create module
  create: async (data: Partial<ExploitModule>): Promise<ApiResponse<ExploitModule>> => {
    const response = await apiClient.post('/exploits', data);
    return response.data;
  },

  // Delete module
  delete: async (id: string): Promise<ApiResponse<null>> => {
    const response = await apiClient.delete(`/exploits/${id}`);
    return response.data;
  },
};

// ==========================================
// PAYLOAD API
// ==========================================

export const payloadApi = {
  generate: async (data: {
    payload?: string;
    format?: string;
    lhost: string;
    lport?: number;
    encoder?: string;
    iterations?: number;
  }): Promise<ApiResponse<{ success: boolean; output: string; format: string }>> => {
    const response = await apiClient.post('/payloads/generate', data);
    return response.data;
  },
};

// ==========================================
// RECONNAISSANCE API
// ==========================================

export const reconApi = {
  // Full recon
  fullRecon: async (target: string, options?: {
    passive?: boolean;
    active?: boolean;
    osDetection?: boolean;
    webRecon?: boolean;
  }): Promise<ApiResponse<ReconResult>> => {
    const response = await apiClient.post('/recon', { target, options });
    return response.data;
  },

  // Port scan
  portScan: async (target: string, ports?: string): Promise<ApiResponse<PortScanResult>> => {
    const response = await apiClient.post('/recon/ports', { target, ports });
    return response.data;
  },

  // Service detection
  serviceDetection: async (target: string, ports?: string): Promise<ApiResponse<ServiceResult>> => {
    const response = await apiClient.post('/recon/services', { target, ports });
    return response.data;
  },

  // OS fingerprinting
  osFingerprint: async (target: string): Promise<ApiResponse<OsResult>> => {
    const response = await apiClient.post('/recon/os', { target });
    return response.data;
  },

  // Web recon
  webRecon: async (target: string): Promise<ApiResponse<WebReconResult>> => {
    const response = await apiClient.post('/recon/web', { target });
    return response.data;
  },
};

// ==========================================
// ATTACK API
// ==========================================

export const attackApi = {
  // SQL injection test
  sqlInjection: async (target: string, options?: {
    data?: string;
    cookie?: string;
  }): Promise<ApiResponse<{ vulnerable: boolean; output: string; databases?: string[] }>> => {
    const response = await apiClient.post('/attacks/sqli', { target, ...options });
    return response.data;
  },

  // Brute force
  bruteForce: async (target: string, options: {
    service?: string;
    username?: string;
    userlist?: string;
    passwordlist?: string;
    threads?: number;
  }): Promise<ApiResponse<{ success: boolean; credentials: { username: string; password: string }[] }>> => {
    const response = await apiClient.post('/attacks/bruteforce', { target, ...options });
    return response.data;
  },
};

// ==========================================
// LEGACY API (backward compatibility)
// ==========================================

export const legacyApi = {
  // Targets
  createTarget: async (data: unknown): Promise<ApiResponse<unknown>> => {
    const response = await apiClient.post('/targets', data);
    return response.data;
  },

  getTargets: async (): Promise<ApiResponse<unknown[]>> => {
    const response = await apiClient.get('/targets');
    return response.data;
  },

  getTarget: async (id: string): Promise<ApiResponse<unknown>> => {
    const response = await apiClient.get(`/targets/${id}`);
    return response.data;
  },

  updateTarget: async (id: string, data: unknown): Promise<ApiResponse<unknown>> => {
    const response = await apiClient.put(`/targets/${id}`, data);
    return response.data;
  },

  deleteTarget: async (id: string): Promise<ApiResponse<null>> => {
    const response = await apiClient.delete(`/targets/${id}`);
    return response.data;
  },

  // Tests
  createTest: async (data: unknown): Promise<ApiResponse<unknown>> => {
    const response = await apiClient.post('/tests', data);
    return response.data;
  },

  getTests: async (): Promise<ApiResponse<unknown[]>> => {
    const response = await apiClient.get('/tests');
    return response.data;
  },

  getTest: async (id: string): Promise<ApiResponse<unknown>> => {
    const response = await apiClient.get(`/tests/${id}`);
    return response.data;
  },

  executeTest: async (id: string): Promise<ApiResponse<unknown>> => {
    const response = await apiClient.post(`/tests/${id}/execute`);
    return response.data;
  },

  getTestStatus: async (id: string): Promise<ApiResponse<unknown>> => {
    const response = await apiClient.get(`/tests/${id}/status`);
    return response.data;
  },

  // Findings
  getFindings: async (): Promise<ApiResponse<unknown[]>> => {
    const response = await apiClient.get('/findings');
    return response.data;
  },

  getFinding: async (id: string): Promise<ApiResponse<unknown>> => {
    const response = await apiClient.get(`/findings/${id}`);
    return response.data;
  },

  verifyFinding: async (id: string): Promise<ApiResponse<unknown>> => {
    const response = await apiClient.put(`/findings/${id}/verify`);
    return response.data;
  },

  exploitFinding: async (id: string): Promise<ApiResponse<unknown>> => {
    const response = await apiClient.post(`/findings/${id}/exploit`);
    return response.data;
  },

  getReport: async (testId: string): Promise<ApiResponse<unknown>> => {
    const response = await apiClient.get(`/reports/${testId}`);
    return response.data;
  },
};

// ==========================================
// EXPORT DEFAULT
// ==========================================

const pentestaiApi = {
  engagement: engagementApi,
  exploit: exploitApi,
  payload: payloadApi,
  recon: reconApi,
  attack: attackApi,
  legacy: legacyApi,
};

export default pentestaiApi;
