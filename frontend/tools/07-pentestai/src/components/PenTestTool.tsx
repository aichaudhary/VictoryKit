import React, { useState, useCallback, useRef, useEffect } from "react";
import {
  Crosshair,
  Terminal,
  Bug,
  Shield,
  Activity,
  Clock,
  Target,
  Zap,
  Server,
  Database,
  Globe,
  RefreshCw,
} from "lucide-react";
import PenTestForm, { PenTestFormData } from "./PenTestForm";
import LiveAttackPanel, {
  AttackPhase,
  AttackEvent,
  ExploitAttempt,
} from "./LiveAttackPanel";
import AnimatedPenTestResult, {
  PenTestResult,
  ThreatLevel,
  ExploitResult,
} from "./AnimatedPenTestResult";
import pentestaiApi, { reconApi, attackApi, engagementApi, exploitApi } from "../services/pentestai.api";

// Simulated exploit database (fallback when API unavailable)
const EXPLOIT_MODULES = [
  {
    name: "EternalBlue",
    module: "exploit/windows/smb/ms17_010_eternalblue",
    severity: "critical" as const,
    accessGained: "system" as const,
  },
  {
    name: "Log4Shell",
    module: "exploit/multi/http/log4j_rce",
    severity: "critical" as const,
    accessGained: "root" as const,
  },
  {
    name: "ProxyShell",
    module: "exploit/windows/http/exchange_proxyshell",
    severity: "critical" as const,
    accessGained: "system" as const,
  },
  {
    name: "SQL Injection Auth Bypass",
    module: "auxiliary/sqli/auth_bypass",
    severity: "high" as const,
    accessGained: "user" as const,
  },
  {
    name: "SSRF to RCE",
    module: "exploit/multi/http/ssrf_rce",
    severity: "high" as const,
    accessGained: "user" as const,
  },
  {
    name: "XSS Session Hijack",
    module: "auxiliary/xss/session_steal",
    severity: "medium" as const,
    accessGained: "user" as const,
  },
  {
    name: "LFI to RCE",
    module: "exploit/multi/http/lfi_to_rce",
    severity: "high" as const,
    accessGained: "root" as const,
  },
  {
    name: "JWT None Algorithm",
    module: "auxiliary/jwt/none_bypass",
    severity: "high" as const,
    accessGained: "user" as const,
  },
  {
    name: "IDOR User Enum",
    module: "auxiliary/idor/user_enum",
    severity: "medium" as const,
    accessGained: "none" as const,
  },
  {
    name: "SSH Brute Force",
    module: "auxiliary/scanner/ssh/ssh_bruteforce",
    severity: "medium" as const,
    accessGained: "user" as const,
  },
];

const PenTestTool: React.FC = () => {
  const [isTesting, setIsTesting] = useState(false);
  const [phases, setPhases] = useState<AttackPhase[]>([]);
  const [events, setEvents] = useState<AttackEvent[]>([]);
  const [exploits, setExploits] = useState<ExploitAttempt[]>([]);
  const [result, setResult] = useState<PenTestResult | null>(null);
  const [progress, setProgress] = useState(0);
  const [accessLevel, setAccessLevel] = useState<
    "none" | "user" | "root" | "system"
  >("none");
  const [targetsCompromised, setTargetsCompromised] = useState(0);
  const [vulnsExploited, setVulnsExploited] = useState(0);
  const [currentPhase, setCurrentPhase] = useState<string | undefined>();
  const [apiConnected, setApiConnected] = useState<boolean | null>(null);
  const [stats, setStats] = useState({
    testsToday: 0,
    exploitsRun: 0,
    breachesFound: 0,
    avgTestTime: 0,
  });

  const abortRef = useRef(false);

  const delay = (ms: number) => new Promise((r) => setTimeout(r, ms));

  // Load stats from API on mount
  useEffect(() => {
    const loadStats = async () => {
      try {
        const [engStats, exploitStats] = await Promise.all([
          engagementApi.getStats(),
          exploitApi.getStats()
        ]);
        
        if (engStats.success) {
          setStats({
            testsToday: engStats.data.totalEngagements || 0,
            exploitsRun: exploitStats.data?.totalModules || 0,
            breachesFound: engStats.data.totalFindings || 0,
            avgTestTime: 28.4,
          });
        }
        setApiConnected(true);
      } catch (error) {
        console.warn('API not available, using simulation mode:', error);
        setApiConnected(false);
        // Set fallback stats for demo
        setStats({
          testsToday: 847,
          exploitsRun: 4829,
          breachesFound: 1247,
          avgTestTime: 28.4,
        });
      }
    };
    loadStats();
  }, []);

  const addEvent = useCallback((event: Omit<AttackEvent, "timestamp">) => {
    setEvents((prev) =>
      [{ ...event, timestamp: Date.now() }, ...prev].slice(0, 100)
    );
  }, []);

  const updatePhase = useCallback(
    (id: string, updates: Partial<AttackPhase>) => {
      setPhases((prev) =>
        prev.map((p) => (p.id === id ? { ...p, ...updates } : p))
      );
    },
    []
  );

  // Run pentest with real API integration
  const runPenTest = async (data: PenTestFormData): Promise<PenTestResult> => {
    const startTime = Date.now();
    const successfulExploits: ExploitResult[] = [];
    let maxAccessLevel: "none" | "user" | "root" | "system" = "none";

    // Initialize phases based on scope
    const testPhases: AttackPhase[] = [
      { id: "init", label: "Initialize Attack Framework", status: "pending" },
      { id: "recon", label: "Reconnaissance", status: "pending" },
      { id: "enum", label: "Service Enumeration", status: "pending" },
      { id: "vuln", label: "Vulnerability Scanning", status: "pending" },
      ...(data.scope !== "reconnaissance"
        ? [
            {
              id: "exploit",
              label: "Exploitation",
              status: "pending" as const,
            },
            {
              id: "post",
              label: "Post-Exploitation",
              status: "pending" as const,
            },
          ]
        : []),
      { id: "report", label: "Generate Report", status: "pending" },
    ];
    setPhases(testPhases);

    // Phase 1: Initialize
    setCurrentPhase("init");
    updatePhase("init", {
      status: "running",
      detail: "Loading exploit modules...",
    });
    addEvent({
      type: "info",
      severity: "info",
      message: "PenTestAI Framework v7.0 initialized",
      command: "./pentest-ai --init",
    });
    await delay(500);
    addEvent({
      type: "info",
      severity: "info",
      message: `Loaded ${EXPLOIT_MODULES.length} exploit modules`,
    });
    addEvent({
      type: "info",
      severity: "info",
      message: `Target: ${data.target}`,
    });
    updatePhase("init", { status: "complete" });
    setProgress(10);

    if (abortRef.current) return null as any;

    // Phase 2: Reconnaissance - Use real API when available
    setCurrentPhase("recon");
    updatePhase("recon", {
      status: "running",
      detail: "Gathering intelligence...",
    });
    addEvent({
      type: "recon",
      severity: "info",
      message: "Starting passive reconnaissance",
      command: `recon-ng -t ${data.target}`,
    });

    let reconData = null;
    if (apiConnected) {
      try {
        addEvent({
          type: "info",
          severity: "info",
          message: "Connecting to PenTestAI reconnaissance engine...",
        });
        const reconResult = await reconApi.fullRecon(data.target, {
          passive: true,
          active: true,
          osDetection: data.scope !== "reconnaissance",
          webRecon: data.target.includes("http") || data.target.includes("www"),
        });
        if (reconResult.success) {
          reconData = reconResult.data;
          addEvent({
            type: "recon",
            severity: "info",
            message: `DNS enumeration complete - ${reconData.summary?.subdomainsFound || 0} subdomains found`,
          });
          addEvent({
            type: "recon",
            severity: "info",
            message: `Open ports discovered: ${reconData.summary?.totalOpenPorts || 0}`,
          });
          if (reconData.active?.os?.os) {
            addEvent({
              type: "recon",
              severity: "info",
              message: `OS detected: ${reconData.active.os.os}`,
            });
          }
        }
      } catch (error) {
        console.warn('Recon API failed, using simulation:', error);
      }
    }
    
    // Fallback to simulation if API not available
    if (!reconData) {
      await delay(600);
      addEvent({
        type: "recon",
        severity: "info",
        message: "DNS enumeration complete - 12 subdomains found",
      });
      await delay(400);
      addEvent({
        type: "recon",
        severity: "info",
        message: "WHOIS lookup complete",
      });
      addEvent({
        type: "recon",
        severity: "info",
        message: "Technology fingerprint: nginx/1.21, Node.js, MongoDB",
      });
    }
    
    updatePhase("recon", {
      status: "complete",
      detail: reconData 
        ? `${reconData.summary?.subdomainsFound || 0} subdomains, ${reconData.summary?.totalOpenPorts || 0} ports`
        : "12 subdomains, 3 technologies",
    });
    setProgress(25);

    if (abortRef.current) return null as any;

    // Phase 3: Enumeration - Use real API for port scanning
    setCurrentPhase("enum");
    updatePhase("enum", {
      status: "running",
      detail: "Enumerating services...",
    });
    addEvent({
      type: "info",
      severity: "info",
      message: "Port scanning initiated",
      command: `nmap -sV -sC ${data.target}`,
    });
    
    let openPorts: { port: number; service?: string }[] = [];
    if (apiConnected && !reconData?.active?.ports) {
      try {
        const portResult = await reconApi.portScan(data.target, "1-1000");
        if (portResult.success && portResult.data.openPorts) {
          openPorts = portResult.data.openPorts.map(p => ({ port: p.port, service: p.service }));
        }
      } catch (error) {
        console.warn('Port scan API failed:', error);
      }
    } else if (reconData?.active?.ports?.openPorts) {
      openPorts = reconData.active.ports.openPorts.map(p => ({ port: p.port, service: p.service }));
    }
    
    // Fallback to simulated ports
    if (openPorts.length === 0) {
      await delay(800);
      openPorts = [22, 80, 443, 3306, 8080]
        .filter(() => Math.random() > 0.3)
        .map(p => ({ port: p }));
    }
    
    for (const portInfo of openPorts) {
      addEvent({
        type: "recon",
        severity: "info",
        message: `Port ${portInfo.port} open${portInfo.service ? ` (${portInfo.service})` : ''}`,
        response: `Service detected`,
      });
      await delay(100);
    }
    updatePhase("enum", {
      status: "complete",
      detail: `${openPorts.length} open ports`,
    });
    setProgress(40);

    if (abortRef.current) return null as any;

    // Phase 4: Vulnerability Scanning
    setCurrentPhase("vuln");
    updatePhase("vuln", {
      status: "running",
      detail: "Scanning for vulnerabilities...",
    });
    addEvent({
      type: "info",
      severity: "info",
      message: "Vulnerability scan started",
      command: `vulnscan --deep ${data.target}`,
    });
    await delay(600);

    const vulnFindings: {
      category: string;
      count: number;
      severity: "critical" | "high" | "medium" | "low" | "info";
    }[] = [];
    
    // Try to get exploit recommendations from API for discovered ports
    if (apiConnected) {
      try {
        const portNumbers = openPorts.map(p => p.port);
        const servicesDetected = openPorts.filter(p => p.service).map(p => p.service!);
        
        // Get exploit recommendations based on discovered services
        const recommendations = await exploitApi.getRecommendations({
          target: data.target,
          ports: portNumbers,
          services: servicesDetected,
          osGuess: reconData?.osFingerprint?.os || undefined,
        });
        
        if (recommendations.success && recommendations.data) {
          // Group recommendations by category
          const vulnsByCategory: { [key: string]: { count: number; maxSeverity: string } } = {};
          
          for (const rec of recommendations.data.recommendations || []) {
            const category = rec.category || 'Misconfiguration';
            if (!vulnsByCategory[category]) {
              vulnsByCategory[category] = { count: 0, maxSeverity: 'info' };
            }
            vulnsByCategory[category].count++;
            
            const severityOrder = ['info', 'low', 'medium', 'high', 'critical'];
            const recSeverity = rec.severity?.toLowerCase() || 'medium';
            if (severityOrder.indexOf(recSeverity) > severityOrder.indexOf(vulnsByCategory[category].maxSeverity)) {
              vulnsByCategory[category].maxSeverity = recSeverity;
            }
          }
          
          for (const [category, info] of Object.entries(vulnsByCategory)) {
            vulnFindings.push({
              category,
              count: info.count,
              severity: info.maxSeverity as any,
            });
            addEvent({
              type: "warning",
              severity: info.maxSeverity as any,
              message: `${category}: ${info.count} potential vulnerabilities`,
            });
            await delay(150);
          }
          
          addEvent({
            type: "info",
            severity: "info",
            message: `API found ${recommendations.data.recommendations?.length || 0} exploit recommendations`,
          });
        }
      } catch (error) {
        console.warn('Exploit recommendations API failed, using simulation:', error);
      }
    }
    
    // Fallback to simulation if no vulnerabilities found via API
    if (vulnFindings.length === 0) {
      const categories = [
        "Remote Code Execution",
        "SQL Injection",
        "XSS",
        "CSRF",
        "Authentication Bypass",
        "Information Disclosure",
      ];

      for (const cat of categories) {
        if (Math.random() > 0.4) {
          const severity =
            Math.random() > 0.7
              ? "critical"
              : Math.random() > 0.5
              ? "high"
              : Math.random() > 0.3
              ? "medium"
              : "low";
          const count = Math.floor(Math.random() * 5) + 1;
          vulnFindings.push({ category: cat, count, severity: severity as any });
          addEvent({
            type: "warning",
            severity: severity as any,
            message: `${cat}: ${count} potential vulnerabilities`,
          });
          await delay(150);
        }
      }
    }

    updatePhase("vuln", {
      status: vulnFindings.some(
        (v) => v.severity === "critical" || v.severity === "high"
      )
        ? "warning"
        : "complete",
      detail: `${vulnFindings.reduce(
        (acc, v) => acc + v.count,
        0
      )} vulnerabilities found`,
    });
    setProgress(55);

    if (abortRef.current) return null as any;

    // Phase 5: Exploitation (if scope allows)
    const attemptedExploits: ExploitAttempt[] = [];

    if (data.scope !== "reconnaissance") {
      setCurrentPhase("exploit");
      updatePhase("exploit", {
        status: "running",
        detail: "Attempting exploitation...",
      });
      addEvent({
        type: "exploit",
        severity: "info",
        message: "Exploitation phase initiated",
        command: "msfconsole -q",
      });

      // Try to use real exploit execution via API
      let apiExploitsExecuted = false;
      
      if (apiConnected && vulnFindings.length > 0) {
        try {
          // Search for exploits matching discovered vulnerabilities
          const searchTerms = vulnFindings.map(v => v.category).join(' ');
          const searchResult = await exploitApi.search({
            query: searchTerms,
            severity: data.intensity === 'aggressive' ? undefined : 'high',
            limit: 5,
          });
          
          if (searchResult.success && searchResult.data?.exploits?.length) {
            apiExploitsExecuted = true;
            
            for (const exploit of searchResult.data.exploits) {
              if (abortRef.current) return null as any;
              
              const exploitAttempt: ExploitAttempt = {
                id: exploit.id || `exp-${Date.now()}-${Math.random()}`,
                name: exploit.name,
                module: exploit.module || exploit.path || 'unknown',
                status: "running",
                target: data.target,
              };
              attemptedExploits.push(exploitAttempt);
              setExploits((prev) => [...prev, exploitAttempt]);
              
              addEvent({
                type: "exploit",
                severity: "high",
                message: `Attempting ${exploit.name}`,
                command: `use ${exploit.module || exploit.path}`,
              });
              await delay(500);
              
              try {
                // Execute exploit via API
                const execResult = await exploitApi.execute({
                  moduleId: exploit.id,
                  target: data.target,
                  options: {
                    RHOSTS: data.target,
                    RPORT: openPorts[0]?.port || 80,
                  },
                  timeout: 30000,
                });
                
                if (execResult.success && execResult.data?.status === 'success') {
                  exploitAttempt.status = "success";
                  setExploits((prev) =>
                    prev.map((e) =>
                      e.id === exploitAttempt.id ? { ...e, status: "success" } : e
                    )
                  );
                  setVulnsExploited((v) => v + 1);
                  
                  const accessGained = execResult.data.accessLevel || 'user';
                  
                  addEvent({
                    type: "success",
                    severity: "critical",
                    message: `${exploit.name} SUCCESSFUL!`,
                    response: `${accessGained.toUpperCase()} shell obtained`,
                  });
                  
                  const accessHierarchy = { none: 0, user: 1, root: 2, system: 3 };
                  if (accessHierarchy[accessGained as keyof typeof accessHierarchy] > accessHierarchy[maxAccessLevel]) {
                    maxAccessLevel = accessGained as any;
                    setAccessLevel(maxAccessLevel);
                    if (accessGained !== "none") {
                      setTargetsCompromised((t) => t + 1);
                    }
                  }
                  
                  successfulExploits.push({
                    id: exploitAttempt.id,
                    name: exploit.name,
                    module: exploit.module || exploit.path || 'unknown',
                    severity: exploit.severity || 'high',
                    status: "success",
                    target: data.target,
                    accessGained: accessGained as any,
                    evidence: execResult.data.output || `shell> whoami\n${accessGained}`,
                    remediation: exploit.remediation || `Patch vulnerable component, update to latest version`,
                  });
                } else {
                  exploitAttempt.status = "failed";
                  setExploits((prev) =>
                    prev.map((e) =>
                      e.id === exploitAttempt.id ? { ...e, status: "failed" } : e
                    )
                  );
                  addEvent({
                    type: "info",
                    severity: "low",
                    message: `${exploit.name} failed - ${execResult.data?.message || 'target not vulnerable'}`,
                  });
                }
              } catch (execError) {
                exploitAttempt.status = "failed";
                setExploits((prev) =>
                  prev.map((e) =>
                    e.id === exploitAttempt.id ? { ...e, status: "failed" } : e
                  )
                );
                addEvent({
                  type: "info",
                  severity: "low",
                  message: `${exploit.name} failed - execution error`,
                });
              }
              await delay(300);
            }
          }
        } catch (error) {
          console.warn('Exploit API failed, falling back to simulation:', error);
        }
      }
      
      // Fallback to simulation if API exploits not executed
      if (!apiExploitsExecuted) {
        const selectedExploits = EXPLOIT_MODULES.sort(
          () => Math.random() - 0.5
        ).slice(0, 5);

        for (const exp of selectedExploits) {
          if (abortRef.current) return null as any;

          const exploitAttempt: ExploitAttempt = {
            id: `exp-${Date.now()}-${Math.random()}`,
            name: exp.name,
            module: exp.module,
            status: "running",
            target: data.target,
          };
          attemptedExploits.push(exploitAttempt);
          setExploits((prev) => [...prev, exploitAttempt]);

          addEvent({
            type: "exploit",
            severity: "high",
            message: `Attempting ${exp.name}`,
            command: `use ${exp.module}`,
          });
          await delay(500);

          // 30-50% chance of success based on intensity
          const successChance =
            data.intensity === "aggressive"
              ? 0.5
              : data.intensity === "active"
              ? 0.35
              : 0.2;
          const success = Math.random() < successChance;

          if (success) {
            exploitAttempt.status = "success";
            setExploits((prev) =>
              prev.map((e) =>
                e.id === exploitAttempt.id ? { ...e, status: "success" } : e
              )
            );
            setVulnsExploited((v) => v + 1);

            addEvent({
              type: "success",
              severity: "critical",
              message: `${exp.name} SUCCESSFUL!`,
              response: `${exp.accessGained.toUpperCase()} shell obtained`,
            });

            // Update max access level
            const accessHierarchy = { none: 0, user: 1, root: 2, system: 3 };
            if (
              accessHierarchy[exp.accessGained] > accessHierarchy[maxAccessLevel]
            ) {
              maxAccessLevel = exp.accessGained;
              setAccessLevel(maxAccessLevel);
              if (exp.accessGained !== "none") {
                setTargetsCompromised((t) => t + 1);
              }
            }

            successfulExploits.push({
              id: exploitAttempt.id,
              name: exp.name,
              module: exp.module,
              severity: exp.severity,
              status: "success",
              target: data.target,
              accessGained: exp.accessGained,
              evidence: `shell> whoami\n${
                exp.accessGained === "root"
                  ? "root"
                  : exp.accessGained === "system"
                  ? "NT AUTHORITY\\SYSTEM"
                  : "user"
              }`,
              remediation: `Patch vulnerable component, update to latest version`,
            });
          } else {
            exploitAttempt.status = "failed";
            setExploits((prev) =>
              prev.map((e) =>
                e.id === exploitAttempt.id ? { ...e, status: "failed" } : e
              )
            );
            addEvent({
              type: "info",
              severity: "low",
              message: `${exp.name} failed - target not vulnerable`,
            });
          }
          await delay(300);
        }
      }

      updatePhase("exploit", {
        status: successfulExploits.length > 0 ? "warning" : "complete",
        detail: `${successfulExploits.length}/${attemptedExploits.length} successful`,
      });
      setProgress(80);

      // Phase 6: Post-Exploitation
      if (successfulExploits.length > 0) {
        setCurrentPhase("post");
        updatePhase("post", {
          status: "running",
          detail: "Post-exploitation activities...",
        });
        addEvent({
          type: "access",
          severity: "high",
          message: "Post-exploitation phase",
          command: "post/multi/gather/env",
        });
        await delay(500);
        
        // Try to create attack path via API
        if (apiConnected) {
          try {
            // Get AI-suggested next steps
            const suggestResult = await attackApi.suggestNextSteps(data.target, {
              currentAccess: maxAccessLevel,
              discoveredServices: openPorts.map(p => p.service).filter(Boolean) as string[],
              successfulExploits: successfulExploits.map(e => e.module),
            });
            
            if (suggestResult.success && suggestResult.data?.suggestions) {
              for (const suggestion of suggestResult.data.suggestions.slice(0, 3)) {
                addEvent({
                  type: "access",
                  severity: "info",
                  message: `AI Suggestion: ${suggestion.action || suggestion.description}`,
                  command: suggestion.command,
                });
                await delay(200);
              }
            }
          } catch (error) {
            console.warn('Attack path API failed:', error);
          }
        }
        
        addEvent({
          type: "access",
          severity: "info",
          message: "Gathering system information...",
        });
        await delay(300);
        addEvent({
          type: "access",
          severity: "info",
          message: "Checking for privilege escalation paths...",
        });
        await delay(300);
        addEvent({
          type: "access",
          severity: "info",
          message: "Extracting credentials from memory...",
        });
        updatePhase("post", { status: "complete", detail: "Data gathered" });
      }
      setProgress(90);
    }

    if (abortRef.current) return null as any;

    // Phase 7: Report Generation
    setCurrentPhase("report");
    updatePhase("report", {
      status: "running",
      detail: "Generating report...",
    });
    addEvent({
      type: "info",
      severity: "info",
      message: "Generating penetration test report...",
      command: "pentest-ai --report",
    });
    await delay(500);
    updatePhase("report", { status: "complete" });
    setProgress(100);

    // Calculate threat level
    const criticalCount =
      vulnFindings.filter((v) => v.severity === "critical").length +
      successfulExploits.filter((e) => e.severity === "critical").length;
    const highCount =
      vulnFindings.filter((v) => v.severity === "high").length +
      successfulExploits.filter((e) => e.severity === "high").length;

    let threatLevel: ThreatLevel;
    let overallScore: number;

    if (
      maxAccessLevel === "system" ||
      maxAccessLevel === "root" ||
      criticalCount >= 2
    ) {
      threatLevel = "CRITICAL";
      overallScore = Math.min(100, 85 + criticalCount * 3);
    } else if (
      maxAccessLevel === "user" ||
      criticalCount >= 1 ||
      highCount >= 3
    ) {
      threatLevel = "HIGH";
      overallScore = Math.min(84, 65 + highCount * 3);
    } else if (highCount >= 1 || vulnFindings.length >= 5) {
      threatLevel = "MEDIUM";
      overallScore = Math.min(64, 45 + vulnFindings.length * 3);
    } else if (vulnFindings.length > 0) {
      threatLevel = "LOW";
      overallScore = Math.min(44, 25 + vulnFindings.length * 3);
    } else {
      threatLevel = "SECURE";
      overallScore = Math.max(5, 10);
    }

    // Generate recommendations
    const recommendations: string[] = [];
    if (criticalCount > 0)
      recommendations.push("Immediately patch critical vulnerabilities");
    if (successfulExploits.length > 0)
      recommendations.push("Review and harden exploited services");
    if (maxAccessLevel !== "none")
      recommendations.push("Implement stronger access controls");
    recommendations.push("Enable intrusion detection systems");
    recommendations.push("Implement network segmentation");
    recommendations.push("Regular security assessments");
    recommendations.push("Security awareness training");

    // Compliance issues
    const complianceIssues: string[] = [];
    if (maxAccessLevel === "root" || maxAccessLevel === "system") {
      complianceIssues.push(
        "PCI-DSS: Requirement 6.5 - Insecure coding practices"
      );
      complianceIssues.push("HIPAA: Access control violations detected");
    }
    if (vulnFindings.some((v) => v.category === "SQL Injection")) {
      complianceIssues.push("OWASP Top 10: A03:2021 Injection vulnerabilities");
    }

    const testDuration = Date.now() - startTime;

    return {
      threatLevel,
      overallScore,
      target: data.target,
      testType: data.testType,
      summary:
        threatLevel === "CRITICAL"
          ? `Critical security breach achieved on ${
              data.target
            }. ${maxAccessLevel.toUpperCase()} level access obtained through ${
              successfulExploits.length
            } successful exploits. Immediate remediation required.`
          : threatLevel === "HIGH"
          ? `High-risk vulnerabilities exploited on ${data.target}. ${successfulExploits.length} exploits succeeded, gaining ${maxAccessLevel} access. Significant security gaps identified.`
          : threatLevel === "MEDIUM"
          ? `Moderate security issues found on ${data.target}. ${vulnFindings.length} vulnerabilities identified. Recommended to address before production.`
          : threatLevel === "LOW"
          ? `Minor issues detected on ${data.target}. ${vulnFindings.length} low-risk findings. Security posture is acceptable.`
          : `Target ${data.target} appears secure. No significant vulnerabilities or successful exploits.`,
      exploitsAttempted: attemptedExploits.length,
      exploitsSuccessful: successfulExploits.length,
      accessLevel: maxAccessLevel,
      exploits: successfulExploits,
      findings:
        vulnFindings.length > 0
          ? vulnFindings
          : [{ category: "No vulnerabilities", count: 0, severity: "info" }],
      recommendations,
      complianceIssues,
      testDuration,
    };
  };

  const handleTest = async (data: PenTestFormData) => {
    setIsTesting(true);
    setResult(null);
    setEvents([]);
    setPhases([]);
    setExploits([]);
    setProgress(0);
    setAccessLevel("none");
    setTargetsCompromised(0);
    setVulnsExploited(0);
    abortRef.current = false;

    try {
      const testResult = await runPenTest(data);
      if (!abortRef.current) {
        setResult(testResult);
        setStats((prev) => ({
          ...prev,
          testsToday: prev.testsToday + 1,
          exploitsRun: prev.exploitsRun + testResult.exploitsAttempted,
          breachesFound:
            prev.breachesFound + (testResult.accessLevel !== "none" ? 1 : 0),
        }));
      }
    } catch (error) {
      console.error("Pentest failed:", error);
      addEvent({
        type: "error",
        severity: "high",
        message: "Test failed. Please try again.",
      });
    } finally {
      setIsTesting(false);
      setCurrentPhase(undefined);
    }
  };

  const handleCancel = () => {
    abortRef.current = true;
    setIsTesting(false);
    setCurrentPhase(undefined);
    addEvent({
      type: "info",
      severity: "info",
      message: "Attack cancelled by operator",
    });
  };

  const handleNewTest = () => {
    setResult(null);
    setEvents([]);
    setPhases([]);
    setExploits([]);
    setProgress(0);
    setAccessLevel("none");
    setTargetsCompromised(0);
    setVulnsExploited(0);
  };

  const handleExport = () => {
    if (!result) return;
    const json = JSON.stringify(result, null, 2);
    const blob = new Blob([json], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `pentest-report-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  };

  return (
    <div className="min-h-screen bg-slate-950">
      {/* Header */}
      <header className="bg-slate-900/80 backdrop-blur-xl border-b border-red-500/20 sticky top-0 z-50">
        <div className="max-w-[1800px] mx-auto px-6 py-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-4">
              <div className="relative">
                <div className="w-12 h-12 rounded-xl bg-gradient-to-br from-red-500 to-orange-500 flex items-center justify-center shadow-lg shadow-red-500/25">
                  <Crosshair className="w-6 h-6 text-white" />
                </div>
                <span className="absolute -top-1 -right-1 w-3 h-3 bg-green-500 rounded-full border-2 border-slate-900 animate-pulse" />
              </div>
              <div>
                <h1 className="text-2xl font-bold bg-gradient-to-r from-red-400 to-orange-400 bg-clip-text text-transparent">
                  PenTestAI
                </h1>
                <p className="text-sm text-gray-500">AI Penetration Testing</p>
              </div>
            </div>

            {/* Live Stats */}
            <div className="hidden lg:flex items-center gap-6">
              <div className="flex items-center gap-2 px-4 py-2 bg-slate-800/50 rounded-lg border border-slate-700">
                <Target className="w-4 h-4 text-red-400" />
                <span className="text-sm text-gray-400">Tests Today:</span>
                <span className="text-sm font-bold text-white tabular-nums">
                  {stats.testsToday.toLocaleString()}
                </span>
              </div>
              <div className="flex items-center gap-2 px-4 py-2 bg-slate-800/50 rounded-lg border border-slate-700">
                <Zap className="w-4 h-4 text-orange-400" />
                <span className="text-sm text-gray-400">Exploits:</span>
                <span className="text-sm font-bold text-orange-400 tabular-nums">
                  {stats.exploitsRun.toLocaleString()}
                </span>
              </div>
              <div className="flex items-center gap-2 px-4 py-2 bg-slate-800/50 rounded-lg border border-slate-700">
                <Bug className="w-4 h-4 text-red-400" />
                <span className="text-sm text-gray-400">Breaches:</span>
                <span className="text-sm font-bold text-red-400 tabular-nums">
                  {stats.breachesFound.toLocaleString()}
                </span>
              </div>
              <div className="flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-red-500/10 to-orange-500/10 rounded-lg border border-red-500/30">
                <Clock className="w-4 h-4 text-green-400" />
                <span className="text-sm text-gray-400">Avg:</span>
                <span className="text-sm font-bold text-white tabular-nums">
                  {stats.avgTestTime}s
                </span>
              </div>
              {/* API Connection Status */}
              <div className={`flex items-center gap-2 px-4 py-2 rounded-lg border ${
                apiConnected === null 
                  ? 'bg-slate-800/50 border-slate-700' 
                  : apiConnected 
                    ? 'bg-green-500/10 border-green-500/30' 
                    : 'bg-yellow-500/10 border-yellow-500/30'
              }`}>
                <div className={`w-2 h-2 rounded-full ${
                  apiConnected === null 
                    ? 'bg-gray-500 animate-pulse' 
                    : apiConnected 
                      ? 'bg-green-500' 
                      : 'bg-yellow-500'
                }`} />
                <span className={`text-sm font-medium ${
                  apiConnected === null 
                    ? 'text-gray-400' 
                    : apiConnected 
                      ? 'text-green-400' 
                      : 'text-yellow-400'
                }`}>
                  {apiConnected === null ? 'Connecting...' : apiConnected ? 'API Live' : 'Demo Mode'}
                </span>
              </div>
            </div>
          </div>
        </div>
      </header>

      {/* Main Content */}
      <main className="max-w-[1800px] mx-auto px-6 py-8">
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Column 1: Form */}
          <div className="lg:col-span-1">
            <PenTestForm
              onTest={handleTest}
              onCancel={handleCancel}
              isTesting={isTesting}
            />
          </div>

          {/* Column 2: Live Attack */}
          <div className="lg:col-span-1">
            <LiveAttackPanel
              phases={phases}
              events={events}
              exploits={exploits}
              isTesting={isTesting}
              currentPhase={currentPhase}
              progress={progress}
              accessLevel={accessLevel}
              targetsCompromised={targetsCompromised}
              vulnsExploited={vulnsExploited}
            />
          </div>

          {/* Column 3: Results */}
          <div className="lg:col-span-1">
            {result ? (
              <AnimatedPenTestResult
                result={result}
                onNewTest={handleNewTest}
                onExport={handleExport}
              />
            ) : (
              <div className="attack-card p-8 h-full flex flex-col items-center justify-center text-center">
                <div className="w-20 h-20 rounded-2xl bg-red-500/10 flex items-center justify-center mb-6">
                  <Shield className="w-10 h-10 text-red-400/50" />
                </div>
                <h3 className="text-xl font-bold text-white mb-2">
                  Penetration Test Results
                </h3>
                <p className="text-gray-500 mb-6 max-w-sm">
                  Configure and launch a penetration test to see breach analysis
                  and exploitation results
                </p>
                <div className="grid grid-cols-2 gap-4 w-full max-w-xs">
                  <div className="p-4 bg-slate-800/50 rounded-lg">
                    <Crosshair className="w-6 h-6 text-red-400 mx-auto mb-2" />
                    <p className="text-xs text-gray-500">Target Analysis</p>
                  </div>
                  <div className="p-4 bg-slate-800/50 rounded-lg">
                    <Zap className="w-6 h-6 text-orange-400 mx-auto mb-2" />
                    <p className="text-xs text-gray-500">Exploit Testing</p>
                  </div>
                  <div className="p-4 bg-slate-800/50 rounded-lg">
                    <Terminal className="w-6 h-6 text-cyan-400 mx-auto mb-2" />
                    <p className="text-xs text-gray-500">Shell Access</p>
                  </div>
                  <div className="p-4 bg-slate-800/50 rounded-lg">
                    <Bug className="w-6 h-6 text-green-400 mx-auto mb-2" />
                    <p className="text-xs text-gray-500">Vuln Reports</p>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      </main>

      {/* Footer */}
      <footer className="border-t border-red-500/20 mt-12">
        <div className="max-w-[1800px] mx-auto px-6 py-6">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2 text-sm text-gray-500">
              <Crosshair className="w-4 h-4 text-red-400" />
              <span>PenTestAI v7.0 • VictoryKit Security Suite</span>
            </div>
            <div className="flex items-center gap-4 text-sm text-gray-600">
              <span>Authorized Testing Only</span>
              <span>•</span>
              <span>AI-Powered</span>
              <span>•</span>
              <span className="text-green-400 flex items-center gap-1">
                <Activity className="w-3 h-3" />
                Online
              </span>
            </div>
          </div>
        </div>
      </footer>
    </div>
  );
};

export default PenTestTool;
